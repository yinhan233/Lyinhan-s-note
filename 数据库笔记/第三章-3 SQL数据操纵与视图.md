## 数据操纵
### 插入数据
两种插入
1. 插入单个元组
2. 插入子查询结果
#### 插入单个元组
![[INSERT.png]]
#### 插入子查询结果
![[INSERT子查询.png]]
example:
![[INSERT子查询实例.png]]
#### 注意事项
##### 1. 基础作用：指定 “表名 + 要插入的列”
不管是插单个元组，还是插子查询的结果，INTO 后面先跟**目标表名**，再跟**要插入的属性列（可选）**。
##### 2. 属性列的顺序，可与表定义不一致
INTO 里写的列顺序，不需要和表本身的列顺序相同，只要**插入的值（或子查询的列）和 INTO 的列顺序对应**即可。
##### 3. 不指定属性列：插入 “完整元组”
如果 INTO 后只写表名、不写列，意味着要插入**表的所有列（完整元组）**：
- 插入单个元组：必须按**表定义的列顺序**提供所有值；
- 插入子查询结果：子查询的列数、顺序必须和**表定义的列完全一致**。
##### 4. 指定部分属性列：其余列取空值
如果 INTO 只写部分列，那么**没指定的列会自动填 NULL**（前提是这些列允许空值）：
- 插入单个元组：只传指定列的值；
- 插入子查询结果：子查询只查指定列的值。
### 修改数据
![[UPDATE.png]]
#### 修改方式
- 修改某个元组的值
- 修改多个元组的值
- 带子查询的修改语句
eg.
![[修改值.png]]
![[修改多个元组.png]]
![[带子查询修改.png]]
### 删除数据
![[删除.png]]
三种删除方式
- 删除某一个元组的值
- 删除多个元组的值
- 带子查询的删除语句
### 数据操纵原则:数据一致性
DBMS在执行插入,删除,更新语句时,必须保证数据库一致性
- 必须有事务的概念和原子性
- 完整性检查和保证
## 视图
### 定义视图
#### 建立视图
![[视图创建.png]]
##### 组成视图的属性列名
全部省略或者全部指定
省略情况:由子查询中SELECT目标列中的诸字段组成
指定情况:
1. 某个目标列是集函数或者列表达式
2. 目标列为*
3. 多表连接时选出了几个同名列作为视图的字段
4. 需要在视图中为某个列启用新的更合适的名字
##### WITH CHECK OPTION
要求更改的时候只更改视图相关
![[视图创建实例.png]]
![[视图更新.png]]
#### 删除视图
`DROP VIEW <视图名>;`
注意事项
1. 该语句从数据字典中删除指定的视图的定义
2. 由该视图导出的其他视图定义仍在数据字典中,但已不能使用,必须显式删除
3. 删除基表时,由该基表导出的所有视图定义都必须显式删除
2的解释:删除一个视图的时候,基于此视图创建的视图就会无法使用,最好先删除子视图
3的解释:删除一个表的时候,基于这个表的视图无法使用,要先被删除
### 查询视图
#### 视图消解法（View Resolution）
- 进行有效性检查，检查查询的表、视图等是否存在。如果存在，则从数据字典中取出视图的定义
- 把视图定义中的子查询与用户的查询结合起来，转换成等价的对基本表的查询
- 执行修正后的查询
###### 解释:
先明确核心前提：视图是 “虚拟表格”（本身不存实际数据，是基于 **基本表（真实存数据的表）** 拼出来的）。所以你查视图时，数据库没法直接查这个 “虚拟表”，得把你的查询转换成 “直接查真实基本表” 的操作 —— 这个转换过程就是 “视图消解法”。
分步骤拆解：
1. 第一步（有效性检查）你说 “我要查视图 A”，数据库先确认：“视图 A 真的存在吗？它依赖的表 / 视图没被删吧？” 要是没问题，就从 “数据字典（数据库的信息登记表）” 里调出视图 A 的定义（比如 “视图 A 是从基本表 X 里挑出年龄 > 18 的记录拼的”）。
2. 第二步（转换查询）假设你查视图 A 的请求是 “找视图 A 里性别为女的记录”，数据库会把 “你的查询” 和 “视图 A 的定义” 结合起来，转换成：“从基本表 X 里挑出‘年龄 > 18 且 性别为女’的记录”—— 相当于把 “查视图” 变成了 “直接查基本表”。
3. 第三步（执行查询）
#### 实体化视图（View Materialization）
- 有效性检查：检查所查询的视图是否存在
- 执行视图定义，将视图临时实体化，生成临时表
- 查询视图转换为查询临时表
- 查询完毕删除被实体化的视图 (临时表)
###### 解释
1. **有效性检查**和之前一样：你说 “查视图 B”，数据库先确认 “视图 B 是不是真的存在、没被删”。    
2. 临时把视图变成真实表（实体化）普通视图是 “虚拟表”（不存实际数据），但这一步里，数据库会按照视图的定义，把视图对应的数据**真实存成一个临时表**（比如视图 B 是 “从学生表挑出高一学生”，这一步就真的把高一学生的数据存成一个临时表 T）。
3. 查临时表代替查视图你要查视图 B 的请求，会变成 “查这个临时表 T”—— 因为临时表 T 里已经存了视图 B 对应的数据，查起来更直接。
4. 查完就删临时表等你拿到查询结果后，数据库会把这个临时表 T 删掉，避免占存储空间。
### 更新视图
#### 更新视图
- DBMS实现视图更新的方法:视图实体化法和视图消解法
- 指定WITH CHECK OPTION子句时,DBMS会在更新视图时进行检查,防止用户通过视图对不属于视图范围内的基本表数据进行更新
#### 更新视图的限制
- 一些视图是不可更新的，因为对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新 (对两类方法均如此)
- 只允许对行列子集视图进行更新
- 对其他类型视图的更新不同系统有不同限制
###### 解释:
先明确核心逻辑：**更新视图，本质是 “让数据库把这个操作转换成对‘视图依赖的基本表’的更新”**—— 如果转不了，这个视图就不能更新。
#### 1. 为什么有的视图 “不可更新”？
比如例子里的 S_G 视图，它是 “按学号分组，计算每个学生的成绩平均分”（基于基本表 SC）。如果你想更新 S_G 里 “学号 95001 的平均分 Gavg 为 90”，数据库会懵：基本表 SC 里，学号 95001 可能有好几门课的成绩（比如数学 80、英语 85，平均分 82.5），现在要把平均分改成 90，**到底改哪门课的成绩？改多少分？没有唯一的改法**。所以这个更新操作没法 “对应到基本表 SC 的具体更新”，这个视图就属于 “不可更新视图”。
![[错误视图创建.png]]
#### 2. 为什么那个 UPDATE 语句执行不了？
你想执行 “把 S_G 里 95001 的 Gavg 改成 90”，不管用之前讲的 “实体化法” 还是 “消解法”，都没法转换成对基本表 SC 的操作 —— 因为平均分是 “计算出来的结果”，不是 SC 里的单个数据，所以数据库做不了这个更新。
![[错误视图更新.png]]
### 视图的作用
- 能够简化用户的操作
- 能使用户以多种角度看待同一数据
- 视图对重构数据库提供了一定程度的逻辑独立性
- 视图能够对机密数据提供安全保护
- 适当利用可使查询表达更清晰