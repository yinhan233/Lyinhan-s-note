## 关系数据结构及形式化
关系模型建立在集合代数的基础上
### 关系数据结构的基本概念
关系,关系模式,关系数据库
#### 关系
相关概念:域、笛卡尔积、关系
##### 域
域是一组具有相同数据类型的值的集合
##### 笛卡尔积
给定一组域D1\~Dn,这些域中可以有相同的D1\~Dn的笛卡尔积为:$\boldsymbol{D}_1 \times \boldsymbol{D}_2 \times \ldots \times \boldsymbol{D}_n = \left\{ \left( \boldsymbol{d}_1, \boldsymbol{d}_2, \ldots, \boldsymbol{d}_n \right) \mid \boldsymbol{d}_i \in \boldsymbol{D}_i,\ i=1,\ 2,\ \ldots,\ n \right\}$
域可以相同。
其中笛卡尔积中每一个元素($\boldsymbol{d}_1, \boldsymbol{d}_2, \ldots, \boldsymbol{d}_n$)叫做一个(n)<font color="#2DC26B">元组</font>
笛卡尔积元素($\boldsymbol{d}_1, \boldsymbol{d}_2, \ldots, \boldsymbol{d}_n$)中的每一个$\boldsymbol{d}_i$叫做一个<font color="#2DC26B">分量</font>
若$\boldsymbol{D}_i$为有限集,则**基数**为$\boldsymbol{m}_i$,则M(笛卡尔积的基数)为$M = \prod_{i=1}^n \boldsymbol{m}_i$
笛卡尔积可表示为一个二维表。表中每行对应一个元组，表中每列对应一个域。
##### 关系
$\boldsymbol{D}_1 \times \boldsymbol{D}_2 \times \ldots \times \boldsymbol{D}_n$的子集叫作在域$\boldsymbol{D}_1$，$\boldsymbol{D}_2$，$\ldots$，$\boldsymbol{D}_n$上的关系，表示为 $$\boldsymbol{R}\left( \boldsymbol{D}_1, \boldsymbol{D}_2, \ldots, \boldsymbol{D}_n \right)$$ $\boldsymbol{R}$：关系名 $n$：关系的目或度（$\mathbf{Degree}$）

注:关系是笛卡尔积的有限子集。无限关系在数据库系统中是无意义的
笛卡尔积不满足交换律,但关系满足
###### 理解:
关系里的行是 “姓名：张三，年龄：20”，交换列变成 “年龄：20，姓名：张三”—— 这俩其实是同一个记录，所以说 “关系满足交换律”。
因为笛卡尔积是 “无序的一堆值”，但关系需要 “有含义的列”—— 给列加上属性名（比如 “姓名”“年龄”），不管列的顺序怎么换，只要属性名对应，就能识别出 “这是同一个记录”，也就解决了笛卡尔积的 “有序性” 问题。
###### 相关概念
元组:关系中的每个元素是关系中的元组,通常用t表示
单/二元关系:当n=1/2时,称该关系为单/二元关系,n为一个关系（表）包含的属性列的数量
关系的表示:关系也是个二维表,表的每行对应一个元组,表的每列对应一个域
属性:关系中不同列可以对应相同的域,为了加以区分,必须对每列起一个名字,称为属性,n目关系有n个属性
码:
候选码:若关系中的某一属性组能唯一地标识一个元组，则称该属性组为候选码。
全码:最极端情况下,关系模式的所有属性组是这个关系模式的候选码
主码:若一个关系有多个候选码，则选定其中一个为主码。主码的诸属性称为主属性，不包含在任何候选码中的属性称为非码属性
###### 三类关系
基本关系(基本表或基表):实际存在的表，是实际存储数据的逻辑表示。
查询表:查询结果对应的表
视图表:有基本表或其他视图表导出的表,是虚表,不对应实际存储的数据。
###### 基本关系的性质
1. 列是同质的:每一列中的分量是同一类型的数据,来自同一个域
2. 不同的列可出自同一个域。其中的每一列称为一个属性,不同的属性要给予不同的属性名
3. 列的顺序无所谓
4. 任意两个元组不能完全相同
5. 行的顺序无所谓
6. 分量必须取原子值,不可再分
#### 关系模式
##### 相关概念
关系模式是型(eg.学生（学号，姓名，年龄）),关系是值。
关系模式是对关系的描述，包括元组集合的结构，即属性构成、属性来自的域以及属性与域之间的映象关系
##### 形式化定义
R(U,D,dom,F)
R->关系名
U->组成该关系的属性名集合
D->属性组U中属性所来自的域
dom->属性向域的映象集合
F->属性间的数据依赖关系集合
###### 关系模式实例：$R=\text{学生}(U,D,\text{dom},F)$
1. **$R$（关系名）**：学生
2. **$U$（属性名集合）**：$U=\{ \text{学号}, \text{姓名}, \text{性别}, \text{年龄} \}$
3. **$D$（属性对应的域）**：
   - $D_1$（学号的域）：8位数字字符串（如“20230001”）
   - $D_2$（姓名的域）：2-4位汉字字符串（如“张三”“李小明”）
   - $D_3$（性别的域）：集合 $\{ \text{男}, \text{女} \}$
   - $D_4$（年龄的域）：18~25的整数（如“20”“22”）
4. **$\text{dom}$（属性→域的映象）**：
   - $\text{dom}(\text{学号}) = D_1$（学号取自8位数字字符串）
   - $\text{dom}(\text{姓名}) = D_2$（姓名取自2-4位汉字字符串）
   - $\text{dom}(\text{性别}) = D_3$（性别取自$\{ \text{男}, \text{女} \}$）
   - $\text{dom}(\text{年龄}) = D_4$（年龄取自18~25的整数）
5. **$F$（属性间的数据依赖）**：
   - $\{ \text{学号} \to \text{姓名}, \text{学号} \to \text{性别}, \text{学号} \to \text{年龄} \}$
   （解释：“学号”能唯一确定对应的姓名、性别、年龄——知道学号，就能找到该学生的其他信息）
关系模式简记:
R(U) or R($A_1,A_2 \ldots A_n$)
R为关系名,$A_i$为属性名
注:域名及属性向域的映象常常直接说明为属性的类型、长度
##### 关系模式与关系
关系模式:对关系的描述，是静态而稳定的
关系:关系模式在某一时刻的状态或内容，是动态的随时间不断变化的
关系和关系模式往往统称关系，可以通过上下文加以区别
## 关系的完整性
主要分为:实体完整性,参照完整性,用户定义的完整性
### 实体完整性
实体完整性规则:若属性A是基本关系R的主属性,则属性A不能取空值
关系模型必须遵守实体完整性规则的原因:
1. 实体完整性规则是针对基本关系而言的
2. 现实世界中的实体和实体间的联系都是可区分的，即它们具有某种唯一性标识
3. 相应的，关系模型中以主码作为唯一性表示
4. 注:主码中的属性即为主属性不能取空
### 参照完整性
主要内容:关系间的引用,外码,参照完整性规则
##### 关系间的引用
**通过 “公共属性（外键）”，将不同关系（表）关联起来，从而表达实体（或实体内部）之间的联系**,往往为一对多,多对多
##### 外码
设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码$K_s$相对应,则F是基本关系R的外码。基本关系R称为参照关系,基本关系S称为被参照关系/目标关系。

拆分理解:R里面有一组属性F是关系S里面的主码,但不是R里面的主码，F称为R的外码,R为参照关系,S为被参照关系

注意:
1. 关系R和S不一定是不同的关系
2. 目标关系S的主码$K_s$和参照关系的外码F必须定义在用一个域上
3. 外码并不一定要与相应的主码同名
4. 当外码与相应的主码属于不同关系时,往往取相同的名字
##### 参照完整性规则
若属性F是基本关系R的外码,它与基本关系S的主码$K_s$相对应(基本关系R和S不一定是不同的关系),则对与R中每个元组在F上的值必须为:
1. 或者取空值
2. 或者等于S中某个元组的主码值
### 用户定义的完整性
概念:用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一应用所涉及的数据必须满足的语义要求
## 关系代数
分为三个部分 概述,传统集合运算,专门集合运算
### 概述
概念：关系代数是一种抽象的查询语言,用对关系的运算来表达查询,包含三个要素:
1. 运算对象:关系
2. 运算结果:关系
3. 运算符:四类
![[关系代数运算符.png]]
![[关系代数运算符-续.png]]
### 传统集合运算
并 交 差 广义笛卡尔积
其实就是离散数学,操作对象成了关系里的元组
差是属于前者,但不属于后者R-S 等价于R的独有元组
广义笛卡尔积输出的表
假设:R:n目$k_1$个元组
	 S:m目$k_2$个元组
	 RxS-->列:(n+m)列的元组的集合
			  前n列是R的一个元组
			  后m列是S的一个元组
		   行:$k_1$x$k_2$个元组
- $R\times S$=$\boldsymbol{R} \times \boldsymbol{S} = \left\{ \widehat{\boldsymbol{t}_r \boldsymbol{t}_s} \mid \boldsymbol{t}_r \in \boldsymbol{R} \land \boldsymbol{t}_s \in \boldsymbol{S} \right\}$
![[笛卡尔积实例.png]]
### 专门的关系运算
##### 表示记号
$\boldsymbol{R}$，$\boldsymbol{t} \in \boldsymbol{R}$，$\boldsymbol{t}[A_i]$ 设关系模式为 $\boldsymbol{R}(A_1, A_2, \ldots, A_n)$ 它的一个关系设为$\boldsymbol{R}$。$\boldsymbol{t} \in \boldsymbol{R}$ 表示 $\boldsymbol{t}$是$\boldsymbol{R}$的一个元组,$\boldsymbol{t}[A_i]$则表示元组$\boldsymbol{t}$中相应于属性$A_i$的一个分量。
$\boldsymbol{A}$，$\boldsymbol{t}[\boldsymbol{A}]$，$\overline{\boldsymbol{A}}$ 若 $\boldsymbol{A} = \left\{ A_{i_1}, A_{i_2}, \ldots, A_{i_k} \right\}$，其中 $A_{i_1}$， $A_{i_2}$，$\ldots$，$A_{i_k}$ 是 $A_1, A_2, \ldots, A_n$ 中的一部分， 则 $\boldsymbol{A}$ 称为属性列或域列。$\boldsymbol{t}[\boldsymbol{A}] = \left( \boldsymbol{t}[A_{i_1}], \boldsymbol{t}[A_{i_2}], \ldots, \boldsymbol{t}[A_{i_k}] \right)$ 表示元组 $\boldsymbol{t}$ 在属性列 $\boldsymbol{A}$ 上诸 分量的集合。$\overline{\boldsymbol{A}}$ 则表示 $\{ A_1, A_2, \ldots, A_n \}$ 中 去掉 $\{ A_{i_1}, A_{i_2}, \ldots, A_{i_k} \}$ 后剩余的属性组。
##### 选择
$\sigma_F(\boldsymbol{R}) = \left\{ \boldsymbol{t} \mid (\boldsymbol{t} \in \boldsymbol{R}) \land F(\boldsymbol{t}) = \text{true} \right\}$ 含义：由$\boldsymbol{R}$中满足$F$条件的元组组成。 其中：$F$由属性名（值）、比较符、逻辑运算符组成。
eg:
![[选择.png]]
##### 投影
从$\boldsymbol{R}$中选择出若干属性列组成新的关系 $\pi_{\boldsymbol{A}}(\boldsymbol{R}) = \left\{ \boldsymbol{t}[\boldsymbol{A}] \mid \boldsymbol{t} \in \boldsymbol{R} \right\}$ $\boldsymbol{A}$：$\boldsymbol{R}$中的属性列
eg:
![[投影.png]]
##### 连接
###### 定义
从两个关系的笛卡尔积中选取属性间满足一定条件的元组
$$\boldsymbol{R} \bowtie_{A\theta B} \boldsymbol{S} = \left\{ \widehat{\boldsymbol{t}_r \boldsymbol{t}_s} \mid \boldsymbol{t}_r \in \boldsymbol{R} \land \boldsymbol{t}_s \in \boldsymbol{S} \land \boldsymbol{t}_r[\boldsymbol{A}] \theta \boldsymbol{t}_s[\boldsymbol{B}] = \text{true} \right\}$$
A和B:分别为R和S上度数相等且可比的属性组
$\theta$:比较运算符
###### 常用连接
等值连接:$\theta$为“=”
含义为从关系R和S的广义笛卡尔积中选取A，B属性值相等的那些元组
自然连接:特殊的等值连接,两个关系中进行比较的分量必须是相同的属性组，结果中把重复属性列去除。
含义为R和S具有相同属性组B

