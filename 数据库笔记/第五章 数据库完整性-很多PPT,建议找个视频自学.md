## 定义
数据库的`完整性`包含数据的`正确性`和`相容性`
数据的完整性与安全性是不同的概念  
完整性:  
- 防止数据库中存在不符合语义的数据,也就是防止数据库中存在不正确的数据
- 防范对象:不合语义的、不正确的数据
数据的安全性
- 保护数据库防止恶意的破坏和非法的存取
- 防范对象:非法用户和非法操作
为了维护,需要:
1. 提供定义的完整性约束条件的机制
2. 提供完整性检查的方法
3. 违约处理
## 完整性控制机制
1. 完整性约束条件定义机制
	数据库完整性一般由DDL语句实现,并把他们作为模式的一部分存入数据库中。
2. 完整性检查机制
	一般在INSERT,UPDATE,DELETE语句执行后开始检查，也可以在事务提交时检查
3. 违约反应
4. 如果发现用户的操作请求使数据违背了完整性约束条件,采取一定的动作
- 拒绝执行该操作
- 级联执行其他操作
## 三类完整性约束
### 实体完整性
- 关系模型的实体完整性
Create Table中用PRIMARY KEY定义
- 单属性构成的码有两种说明方法
1. 定义为列级约束条件
2. 定义为表级约束条件
- 对多个属性构成的码只有一种说明方法
定义为表级约束条件  

eg:![[列级定义.png]]
![[表级定义.png]]
#### 有啥区别?:
##### 1. 列级定义主码（如示例 1）
- 写法：直接在**单个列的定义后**加 `PRIMARY KEY`（比如 `Sno CHAR(9) PRIMARY KEY`）。
- 限制：**只能定义 “单个列” 作为主码**，无法实现 “多列组合的复合主码”。
##### 2. 表级定义主码（如示例 2）
- 写法：在所有列定义完成后，单独用 `PRIMARY KEY (列名)` 声明（比如 `PRIMARY KEY (Sno)`）。
- 优势：不仅能定义 “单个列主码”，还支持**多列组合的复合主码**（比如主码是`Sno`+`Cno`时，可写`PRIMARY KEY (Sno, Cno)`）。

#### 实体完整性检查和违约处理
在插入记录或更新主码列时,系统会自动进行完整性检查
1. 检查主码是否唯一,如果不唯一则拒绝插入或修改
2. 检查主码各个属性是否为空,只要有一个就拒绝插入或修改
在检查是否唯一的时候，检查方法是进行**全表扫描**
为了避免对基本表进行全表扫描,一般会自动建立一个**索引**
### 参照完整性
关系模型的参照完整性在CREATE TABLE中定义
- FOREIGN KEY子句定义外码列
- REFERENCES子句:外码相应于哪个表的主码
eg:
![[FR参照完整性.png]]
违约处理:
![[参照与被参照.png]]
![[参照完整性在Create.png]]
![[显示.png]]
### 用户定义完整性
两类方法:
1. 用CREATE TABLE语句在建表时定义用户完整性约束
2. 通过触发器来定义用户完整性规则
两类约束:
- 属性上的约束
- 元组上的约束
#### 用CREATE TABLE语句在建表时定义用户完整性约束
可定义三类完整性约束:
- 列值非空(NOT NULL短语)
- 列值唯一(UNIQUE短语)
- 检查列值是否满足一个布尔表达式(CHECK短语)
eg:
![[CHECKEXAMPLE.png]]
![[CHECKEXAMPLE2.png]]![[constraint.png]]
![[CONSTRAINT phrase.png]]
![[ALTER CONSTRAINT.png]]
![[DOMAIN.png]]
![[assertion.png]]![[CREATE ASSERTION.png]]![[ASSERTIONEXP.png]]![[DROPASSERTION.png]]
#### 通过触发器来定义用户完整性规则
![[TRIGGRT.png]]
![[CTRIGGER.png]]![[TRIGGER NOTICE.png]]![[WHAT ISTRIGGER.png]]
![[TRIGGER XU.png]]![[TRIGGER ELSE.png]]![[DROP TIGGER.png]]