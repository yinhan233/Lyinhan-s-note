## 数据库设计
- 数据库概念设计(ER模型)
- 数据库逻辑设计(规范化理论)
	- 关系数据库逻辑设计:针对一个问题，如何设计一个适合于它的数据库模式,即数据库中应该有几张表,表中的列又是如何生成的,字段间表间关系? 
- 数据库物理设计
## 单一关系模式的问题
eg:Student(Sno,Sdept,Sloc,Cno,Grade)
	Key应设置为什么
	这样子设计好不好?
可能的问题
- 插入异常:假设Sno=95102,Sdept=IS,Sloc=N的学生没有选课,但是因为课程号是主属性,该学生信息无法插入Sloc
- 删除异常:假定某个学生只选修了3,现在身体不适,3号课不选修了，因为课程号是主属性,操作将导致该学生信息的整个元组被删除
- 数据冗余:选修了10门课,则Sdept,Sloc值存储了10次
- 修改复杂:转系的时候要无遗漏的修改Sloc,Sdept等信息
- 好的关系模式:没有插入异常，删除异常，更新异常，数据冗余小
原因:模式中的数据依赖
解决方法:用规范化理论改造关系模式来消除其中不合适的数据依赖
## 关系模式的形式化定义
R(U,D,DOM,F)
R--关系名
U--组成该关系的属性名集合
D--属性组U中属性所来自的域
DOM--属性向域的映象集合
F--属性间数据的依赖关系集合
## 数据依赖
数据以来的主要类型:函数依赖和多值依赖
### 函数依赖
#### 基本概念
定义:设R(U)是一个属性集U上的关系模式,X和Y是U的子集。若对于R(U)的任意一个可能的关系r,r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称"X函数确定Y”或“Y函数依赖于X”记作X->Y
简记:X相等,Y也一定要相等
若 X->Y Y->X 那么 X<-->Y
若Y不依赖于X 那么X~~-X~~>Y
#### 平凡函数依赖与非平凡函数依赖
在R(U)中,对于U的子集X和Y
如果X->Y但Y不为X的子集 则 X->Y是非平凡函数依赖
如果X->Y但Y为X的子集 则 X->Y是平凡函数依赖
eg:
(Sno,Cno)->Grade   非平凡函数依赖
(Sno,Cno)->Sno     平凡函数依赖
若X->Y则称X是这个函数依赖的决定因素
#### 完全函数依赖与部分函数依赖
在关系R(U)中，如果X->Y,并且对于X的任何一个真子集X，都有X’~~X-~~>Y，则称Y完全函数依赖与X，记作X~~f>~~Y
若X->Y，但Y不完全函数依赖于X，则称Y部分函数依赖于X，记作X-~~p~~>Y
(感觉还是举例好理解点，，)
##### example:
`Student(Sno, Sdept, Mname, Cname, Grade)`

- Sno：学号（唯一对应一个学生）
- Sdept：学生所在系
- Mname：系主任（一个系对应一个主任）
- Cname：课程名
- Grade：某学生某门课的成绩

###### 例子 1：完全函数依赖（X→f Y）

**依赖关系**：`(Sno, Cname) → Grade`（解释：“学号 + 课程名” 能唯一确定这门课的成绩）

**为什么是 “完全” 依赖？** 看`(Sno, Cname)`的**真子集**（比如单独的`Sno`，或单独的`Cname`）：
- 只靠`Sno`（学号）：一个学生可能选多门课，无法确定某一门课的成绩；
- 只靠`Cname`（课程名）：一门课有多个学生选，无法确定某一个学生的成绩。
→ 所以`(Sno, Cname)`的**任何真子集都不能推出 Grade**，因此`Grade完全函数依赖于(Sno, Cname)`，记作`(Sno, Cname) →f Grade`。
###### 例子 2：部分函数依赖（X→p Y）
**依赖关系**：`(Sno, Cname) → Sdept`（解释：“学号 + 课程名” 能推出学生所在系）
**为什么是 “部分” 依赖？** 看`(Sno, Cname)`的真子集`Sno`：
- 只靠`Sno`（学号）：一个学号对应唯一的系，已经能直接推出`Sdept`了，不需要额外加`Cname`。
→ 所以`(Sno, Cname)`里的**部分属性（Sno）就能推出 Sdept**，因此`Sdept部分函数依赖于(Sno, Cname)`，记作`(Sno, Cname) →p Sdept`。
## 码
- 候选码:若关系中某一属性组的值能唯一地标识一个元组，则称该属性组为候选码
- 最简单情况下,候选码只包含一个属性。
- 最极端情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码。
若一个关系有多个候选码，则选定其中一个为主码
候选码的诸属性称为主属性
不包含任何候选码的属性为非码属性
## 范式
- 范式是符合某一种级别的关系模式的集合
1NF :每个属性不可分
2NF(完全依赖):满足第一范式，每一个非主属性都完全函数依赖于R的码
注意:**只有当决定因素 X 是 “多个属性组成的集合（复合属性）” 时，才会区分 “完全 / 部分函数依赖”；如果 X 是单个属性，不存在 “部分函数依赖”，但仍然有 “完全函数依赖”**。
3NF(传递问题):关系模式中若不存在码X，属性组Y以及非主属性Z组(Z不为Y子集)
非主属性不能传递依赖于主键”**，而**主属性之间的传递依赖，3NF 是不管的。
例如:
- 传递依赖：`Sno→Sdept`，`Sdept→Mname` → 非主属性 Mname 传递依赖于主键 Sno → 不满足 3NF。