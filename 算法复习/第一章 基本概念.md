# 算法分析概念
## 引入
#### 算法的定义
算法是定义好的能够完成一定任务的有限指令集合，通常由一个初始化状态，终止于一个对应的可识别的结束状态。
#### 算法的特征
有效性:算法必须能在有限的时间能够完成
确定性:算法的每一步能够清楚的定义
有限性:算法能够在有限的步骤完成
输入:有0个或多个
输出:至少1个
#### 算法的性能
空间/时间复杂度
其他的所需资源:通讯开销，处理器数目，等...
## 搜索问题
### 线性搜索
```伪代码
Input:An array A[1..n] of n elements and an element x.
Output:j if x=A[j], 1≤j≤n, and 0 otherwise.
1. j←1
2. while (j<n) and (x≠A[j])
3. j←j+1
4. end while
5. if x=A[j] then return j else return 0.
```
时间复杂度:O(n)
### 二分搜索
```
Input: 数组 A [1..n] 包含 n 个非递减次序的元，查找元素 x.
Output: j 若 x = A [j], 1 ≤ j ≤ n, and 0 otherwise.
1. low ← 1; high ← n; j ← 0
2. while (low ≤ high) and (j = 0)
3. mid ← ⌊(low+high)/2⌋
4. if x = A[mid] then j ← mid
5. else if x < A[mid] then high ← mid − 1
6. else low ← mid + 1
7. end while
8. return j
```
时间复杂度:O(logn)
## 排序问题
### 选择排序
思想:A[1]为最小元素，接着,从剩下的n-1个元素找最小的,存在A[2],重复以上过程，直到整个数组中第二大的元素存在A[n-1]
```伪代码
Input: 包含 n 个元素的数组 A [1..n].
Output: 使 A [1..n] 中的元素非递减排列
1. for i ← 1 to n-1
2. k ← i // 记录第 i 个最小元素的下标
3. for j ← i+1 to n
4. if A[j] < A[k] then k ← j
5. end for
6. if k ≠ i then 交换 A [i] 和 A [k]
7. end for
```
时间复杂度O(n^2)
### 插入排序
思想:从只包含一个元素的子数组A[1]开始,将A[2]插入到子数组A[1]的合适的位置,可能在A[1]前或后,之后A[1..2]变成有序的,重复该步骤
```伪代码
Input: An array A[1..n] of n elements.
Output: A[1..n] sorted in nondecreasing order.
1. for i ← 2 to n
2. x ← A[i]
3. 

4. while (j>0) and (A[j]>x)
5. A[j+1] ← A[j]
6. j ← j−1
7. end while
8. A[j+1] ← x
9. end for
```
时间复杂度:O(n^2)
### 合并两个有序的数组
思想:双指针法
```
Input: 数组 A [1..m] 和三个下标 p, q, r，其中 1≤p≤q<r≤m。该数组的两个子部分 A [p..q] 和 A [q+1..r] 是非递减排序
Output: A [p..r] 中的元素非递减排序
1. component ← q-p+1; k ← p
2. s ← p; t ← q+1 //s 是第一个子数组的指针，t 是第二个子数组的指针
3. while s ≤ q and t ≤ r
4. if A[s] ≤ A[t] then
5. B[k] ← A[s]; s ← s+1
6. else
7. B[k] ← A[t]; t ← t+1
8. end if
9. k ← k+1
10. end while
11. if s = q+1 then B[k..r] ← A[t..r]
12. else B[k..r] ← A[s..q]
13. A[p..r] ← B[p..r]
14. end for
```
时间复杂度:O(r−p+1)
### 自底向上合并
```
Input: 包含 n 个元素的数组 A [1..n]
Output: A [1..n] 按照非递减排序.
1. k ← 1 //k 是当前待合并的有序块的大小（初始每个元素为 1 个元素的有序块）
2. while k < n
3. s ← k; t ← 2*s; i ← 0 //t 是合并后块的大小，i 是当前合并的起始偏移
4. while i + t ≤ n // 遍历数组，合并相邻的两个大小为 s 的有序块
5. MERGE (A, i+1, i+s, i+t) // 合并 A [i+1..i+s] 和 A [i+s+1..i+t]
6. i ← i + t // 移动到下一组待合并的块
7. end while
8. if i + s <n then MERGE (A, i+1, i+s, n) // 合并剩余的不足 t 大小的块
9. k ← t // 块大小翻倍，进入下一轮合并
10. end while
```
时间复杂度:O(nlogn)
## 算法分析概念
### 时间/空间复杂度
#### 时间复杂度
定义:对于输入规模n的算法元运算的次
元运算:对于任何计算步骤，它的代价有一个时间常量作为上界,而不管输入数据或执行的算法
Example:
加减乘除,元素比较和逻辑元算,元素赋值

| 符号      | 核心含义        | 对应算法场景     | 关键特征          |
| ------- | ----------- | ---------- | ------------- |
| O(g(n)) | 渐近上界        | 最坏时间复杂度    | 只约束「上限」，不约束下限 |
| Ω(g(n)) | 渐近下界        | 最好时间复杂度    | 只约束「下限」，不约束上限 |
| Θ(g(n)) | 渐近紧确界（精确量级） | 最好=最坏时间复杂度 | 同时约束「上限」和「下限」 |
#### 空间复杂度
定义:为了求解问题的实例而执行的计算步骤所需要的内存空间，即算法所需要的工作空间
### 最优算法
定义：一般说来，如果我们能够证明解决问题$\pi$的时间复杂度为Ω(f(n)), 那么一个时间复杂度为O(f(n))的算法Q称为一个最优算法
### 如何评估算法运行时间
- 计算迭代的次数
- 计算基本操作的频度
 如果算法中的一个<font color="#2DC26B">元运算</font>具有<font color="#2DC26B">最高频率</font>，所以其他元运算频率均在他的频率的常数倍内，则这个元运算称为<font color="#2DC26B">基本运算</font>
√在搜索和排序算法中，元运算一般是元素比较
√在矩阵乘法运算中，数量乘法运算是元运算
√在遍历一个链表时，元运算是设置或更新指针
√在图遍历中，元运算是访问节点的 “动作” 和被访问节点的计数
- 使用递推关系
### 最坏和平均情况分析
不知道写啥
# 数学预备知识(AI总结)都学过
## 一、数学预备知识
### 1. 集合、关系和函数（算法分析核心基础）
- **集合**：定义为对象的集合，含有限 / 无限、可数 / 不可数（整数可数、实数不可数）分类；涵盖基数（元素个数）、成员关系（∈/∉）、子集（⊆）、幂集（所有子集的集合，|P (A)|=2ⁿ），及并集（∪）、交集（∩）、差集（-）、补集（Ā）的定义与符号。
- **关系**：二元关系是笛卡尔积（A×B，所有有序对集合）的子集，含定义域（Dom (R)）、值域（Ran (R)）；核心性质包括自反 / 反自反、对称 / 非对称 / 反对称、传递，满足自反 + 反对称 + 传递的为偏序；等价关系（自反 + 对称 + 传递）可将集合划分为等价类（如模 n 同余关系）。
- **函数**：特殊二元关系（每个定义域元素对应唯一值域元素），含单射（不同输入映射不同输出）、满射（值域覆盖目标集合）、双射（既是单射也是满射）分类。
### 2. 证明方法
- 直接证明：假设 P 真，推导 Q 真（如 “n 是偶数则 n² 是偶数”）。
- 间接证明：证明逆反命题 ¬Q→¬P（如 “n² 是偶数则 n 是偶数”）。
- 反证法：假设 P 真且 Q 假，导出矛盾。
- 反例证明法：用单个反例否定命题（如 f (n)=n²+n+41，f (40)=41² 为合数）。
- 数学归纳法：含基础步（证明 n₀成立）和归纳步（假设 n₀到 n-1 成立，推导 n 成立），例证明伯努利不等式：(1+x)ⁿ≥1+nx（x≥-1，n 为自然数）。
### 3. 对数
- 定义：若 y=bˣ（b>1），则 x=log_b y；核心运算性质为 log_b (xy)=log_b x+log_b y、log_b (cʸ)=y log_b c；特殊底数：b=2 记为 log x，b=e（自然常数，e≈2.718）记为 ln x。
### 4. 底函数和顶函数
- 底函数⌊x⌋：小于等于 x 的最大整数；顶函数⌈x⌉：大于等于 x 的最小整数；含核心等式（如 -⌈x⌉=⌊-x⌋）及相关定理（单调递增函数的底 / 顶函数运算性质）。
### 5. 阶乘和二项式系数
- 阶乘：n! =n×(n-1)×…×1（0!=1），n 个对象取 k 个的排列数 Pₖⁿ=n!/(n-k)!。
- 二项式系数：从 n 个对象取 k 个的组合数（与顺序无关），满足对称性质（Cₖⁿ=Cₙ₋ₖⁿ）、递归公式（Cₖⁿ=Cₖⁿ⁻¹+Cₖ₋₁ⁿ⁻¹），对应二项式定理：(1+x)ⁿ=Σ（Cⱼⁿxʲ）（j 从 0 到 n）。
### 6. 鸽巢原理（狄利克莱抽屉原理）
- 简单形式：K+1 个物体放入 K 个盒子，至少 1 个盒子含≥2 个物体（如 13 人中必有 2 人生日同月）。
- 推广形式：n 个球放入 m 个盒子，至少 1 个盒子含≥⌈n/m⌉个球，最多含≤⌊n/m⌋个球（如 100 人中至少 9 人生日同月）；应用于图论（连通图中长于顶点数的路径必含回路）。
### 7. 和式
- 核心方法：通过积分近似单调函数的和式，根据函数增减性给出和式的上下界。
## 二、数学工具（递推关系）
### 1. 定义与分类
- 递推关系：用自身前 k 项定义的公式（如正奇数序列），是计数问题的核心工具；分为：    
    - 常系数线性齐次递推式：f (n)=a₁f (n-1)+…+aₖf (n-k)（aₖ≠0）。
    - 非齐次递推式：上述形式加附加项 g (n)（常量或 n 的函数）。
### 2. 求解方法
- 线性齐次递推式：通过特征方程求根，k 个互异特征根 r₁…rₖ对应的通解为 f (n)=c₁r₁ⁿ+…+cₖrₖⁿ；例：斐波那契数列（Fₙ=Fₙ₋₁+Fₙ₋₂，F₁=F₂=1）。
- 非齐次递推式：给出特定形式的解析解（如 f (n)=f (n-1)+g (n) 的解为 f (0)+Σg (i)）。
- 分治递推式（算法分析常用）：
    - 展开递推式：反复展开递归式求解（例 f (n)=2f (n/2)+bn log n 的解为 Θ(n log²n)）。
    - 代入法：猜想解的形式，用数学归纳法验证（例 f (n)=f (⌊n/2⌋)+f (⌈n/2⌉)+bn 的解为 Θ(n log n)）。
    - 更换变元：通过定义域转换简化递推关系求解。
# 数据结构(AI总结)都学过
## 一、基本概念与术语
1. 核心定义
    - 数据（Data）：能输入计算机并被处理的符号总称。
    - 数据元素（Data Element）：数据的基本处理单位，可由若干数据项（不可分割最小单位）组成。
    - 数据对象（Data Object）：性质相同的数据元素集合，是数据的子集。
    - 数据结构（Data Structure）：存在特定关系的数据元素集合，包含逻辑结构、物理结构和数据运算。
2. 逻辑结构（数据元素间关系）
    - 集合：元素仅同属一种类型，无其他关系。
    - 线性结构：一对一关系（如线性表、栈、队列）。
    - 树形结构：一对多关系（如树）。
    - 图状结构（网状结构）：多对多关系（如图）。
3. 存储结构（数据在计算机中的表示）
    - 顺序存储结构：借助元素存储的相对位置表示逻辑关系。
    - 链式存储结构：借助指针指示元素地址表示逻辑关系。
    - 关联：算法设计依赖逻辑结构，算法实现依赖存储结构。
4. 数据运算：检索、排序、插入、删除、修改等。
## 二、链表

1. 定义与结构：由节点序列组成，节点含信息域和指向其他节点的链（指针），包含前驱节点、后续节点、表头（指向首个元素的链）概念。
2. 链表类型
    - 普通链表：基础节点序列结构。
    - 循环链表：最后一个元素的链指向第一个元素。
    - 双向链表：每个节点（除首节点外）同时指向前驱和后续节点。
    - 循环双向链表：首尾节点相互链接，且每个节点含前驱、后续指针。
3. 存储与操作
    - 节点类型定义：通过结构体实现，包含数据域和指针域（如`StudType`结构体）。
    - 核心操作：插入、删除，耗时固定（与数组相比无需元素移动）。
    - 与数组对比：数组顺序存储，插入 / 删除需移动元素；链表链式存储，插入 / 删除仅需调整指针。
## 三、堆栈和队列（受限线性结构）
### （一）堆栈
1. 定义与特性：限定在栈顶一端进行插入（入栈，Push）和删除（出栈，Pop）的线性表，满足 “后进先出（LIFO）”。
2. 关键概念：栈顶（操作端）、栈底（固定端）、空栈（无元素）。
3. 存储实现：可通过一维数组（用`top`指针记录栈顶下标）或链表实现。
4. 应用：编译系统处理算术表达式（如`X+Y*Z`，用两个堆栈分别存储运算数和运算符）。
### （二）队列
1. 定义与特性：仅允许在队尾插入（入队）、队头删除（出队）的线性表，满足 “先进先出（FIFO）”。
2. 关键概念：队尾（Rear，插入端）、队头（Front，删除端）。
3. 存储实现：可通过数组或链表实现。
4. 问题与解决：数组存储时易因两端移动导致 “假溢出”，解决方案包括 “元素前移” 和 “循环队列”（数组头尾相接）。
5. 循环队列判断：满队列（队尾循环至队首前一个单元，`r=f`时插入会覆盖）；空队列（删除最后一个元素后，`f=r`）。
## 四、树结构
### （一）基础树概念
1. 自由树与森林：自由树是无回路的连通无向图；森林是顶点不相交的树的集合。
2. 树的定理（n 个顶点的树）：任意两顶点有唯一路径；恰好 n-1 条边；加一条边构成回路。
3. 应用场景：家谱、行政组织、编译程序语法结构、数据库信息组织、算法执行过程描述。
### （二）根树
1. 定义：带特殊根节点（r）的树。
2. 核心概念：父 / 子节点、兄弟节点、叶子（无子女）、内部顶点（非叶子）、祖先 / 后代、子树（以某顶点为根的后代集合）、深度（根到顶点的路径长度，根深度为 0）、高度（顶点到叶子的最长路径长度，树高为根的高度）。
### （三）树的遍历（根树）
1. 前序遍历：先访问根，再依次前序遍历各子树。
2. 中序遍历：先中序遍历第一个子树，再访问根，再依次中序遍历其余子树。
3. 后序遍历：先依次后序遍历各子树，最后访问根。
### （四）二叉树
1. 定义：节点集合为空，或由根节点和两个不相交的左右子树组成（与根树的区别：可空；左右子树有区分）。
2. 类型：
    - 满二叉树：每个内部节点恰好有两个子女。
    - 完全二叉树：满二叉树且所有叶子深度相同。
    - 几乎完全二叉树：除最右侧可能缺少若干叶子外，其余丰满。
3. 存储结构：
    - 顺序存储：完全 / 几乎完全二叉树用数组存储，`A[j]`的左右子女存于`A[2j]`和`A[2j+1]`，父节点存于`A[⌊j/2⌋]`。
    - 链式存储：二叉链表（含数据域、左 / 右指针域）；三叉链表（新增父指针域，便于查找双亲）。
4. 定量特征：
    - 第 j 层最多有 2^j 个顶点。
    - 高度为 k 的二叉树，顶点数 n 满足`n ≤ 2^(k+1)-1`（完全二叉树等号成立）；几乎完全二叉树满足`2^k ≤ n ≤ 2^(k+1)-1`。
### （五）二叉搜索树
1. 定义：顶点标记满足 “左子树元素＜根元素＜右子树元素” 的二叉树，表示集合不唯一，最坏情况退化为单链。
2. 支持操作：插入、删除、成员身份测试、检索最大 / 最小值。
3. 优势：改善搜索性能，最坏情况比较次数为树的深度（远优于线性链表）。
### （六）赫夫曼树及其应用
1. 定义：带权路径长度（WPL，所有叶子节点路径长度 × 权值之和）最短的树（最优树）。
2. 构造步骤：
    - 由 n 个权值构造 n 棵单节点二叉树集合。
    - 每次选权值最小的两棵树作为左右子树，构造新树（根权值为子女权值和）。
    - 删除原两棵树，加入新树，重复至集合只剩一棵树。
3. 应用：
    - 判定树：优化条件判断效率（如百分制转等级的最佳判定逻辑）。
    - 赫夫曼编码：满足 “唯一性（前缀编码）” 和 “最短长度”，高频字符用短编码，低频用长编码，基于赫夫曼树生成。
## 五、图结构
### （一）图的基本概念
1. 定义：`G=(V,E)`，V 为顶点集合，E 为边集合；分无向图（边为无序顶点对）和有向图（边为有序顶点对）。
2. 核心术语：
    - 邻接：无向图中边的两顶点互邻，有向图中仅后续顶点邻接于前驱顶点。
    - 度：无向图顶点的邻接顶点数；有向图含入度（入边数）和出度（出边数）。
    - 路径：顶点序列，边数为路径长度；简单路径（顶点不重复）、回路（首尾顶点相同）。
    - 连通性：无向图中任意两顶点可达为连通；有向图中子集内双向可达为强连通分支。
    - 特殊图：完全图（任意两顶点间有边）、二分图（顶点分两子集，边仅跨子集）。
### （二）图的存储结构
1. 邻接矩阵：n×n 布尔矩阵，`M[i,j]=1`表示顶点`v_i`与`v_j`有边；无向图矩阵对称，有向图不对称；带权图可将 1 替换为边权。
2. 邻接表：每个顶点对应一个单链表，存储邻接顶点（无向图一条边对应两个节点，有向图一条弧对应一个节点）；存储复杂度`Θ(m+n)`（n 为顶点数，m 为边数），表示不唯一。
### （三）平面图
定义：可嵌入平面且边无交叉的图。
### （四）最短路径
1. 问题定义：带权图中，求源点到其他顶点的路径，使边权之和最小（边权均大于 0）。
2. Dijkstra 算法：
    - 核心思想：将顶点分为 P 标号集（已确定最短路径）和 T 标号集（暂存路径长度），逐步将 T 标号顶点转为 P 标号。
    - 步骤：初始化源点为 P 标号，其余为 T 标号；反复选 T 中距离最小顶点加入 P 标号，更新剩余 T 标号顶点距离；直至所有顶点进入 P 标号
# 堆和不相交集
## 堆
- 定义:一个几乎完全的二叉树，每个节点都满足堆的特征:如何v和p(v)分别是节点和它的父节点，那么存储在p(v)中的数据项键值不小于存储在v中数据项的键值(子树值比父亲小)  
- 表示方式:一个有n个节点的堆T,可以用一个数组$H[1..n]$  
  - T的根节点存在$H[1]$  
  - 假设T的节点x存在$H[j]$中，左节点存于$H[2j]$，右节点存于$H[2j+1]$  
  - $H[j]$的父节点如果不是根节点，则父节点存储在$H[\lfloor j/2 \rfloor]$  
- 支持的运算:  
  - delete-max$[H]$:删除最大键值  
  - insert$[H,x]$:插入x到堆H  
  - delete$[H,i]$:删除第i项  
  - makeheap$[A]$:转换数组A到堆  
### 堆上的运算
#### shift-up  
作用:沿着$H[i]$到根节点的唯一一条路径,把$H[i]$移到合适的位置,在沿着路径的每一步上,$H[i]$键值和它父节点的键值$H[\lfloor i/2 \rfloor]$相比较   
`伪代码:`  
输入:数组$H[1..n]$和位于1和$n$之间的索引$i$   
输出:上移$H[i]$（如果需要），以使它不大于父节点。   
1. $done \leftarrow false$ 
2. if $i=1$ then exit {节点$i$为根} 
3. repeat 
4. if $key(H[i])>key(H[\lfloor i/2 \rfloor])$ then 互换$H[i]$和$H[\lfloor i/2 \rfloor]$ 
5. else $done \leftarrow true$ 
6. $i \leftarrow \lfloor i/2 \rfloor$ 
7. until $i=1$ or $done$
#### shift-down
作用:和shift-up相反
`伪代码:`
输入:数组$H[1..n]$和位于1和$n$之间的索引$i$
输出:下移$H[i]$（如果需要），以使它不小于子节点。 
1. $done \leftarrow false$ 
2. if $2i > n$ then exit {节点$i$是叶子} 
3. repeat 
4. $i \leftarrow 2i$ 
5. if $i+1 \leq n$ and $key(H[i+1])>key(H[i])$ then $i \leftarrow i+1$ 
6. if $key(H[\lfloor i/2 \rfloor]) < key(H[i])$ then 互换$H[i]$和$H[\lfloor i/2 \rfloor]$ 
7. else $done \leftarrow true$ 
8. end if 
9. until $2i > n$ or $done$
#### insert  
思想:将数字插入数组末尾，数组大小加一，然后通过shift-up移动到合适位置  
`伪代码:`  
输入: 堆$H[1..n]$和元素$x$。 
输出: 新的堆$H[1..n+1]$，$x$为其元素之一。 
1. $n \leftarrow n+1$ {增加$H$的大小}  
2. $H[n] \leftarrow x$  
3. $\text{SHIFT-UP}(H, n)$  
时间复杂度:O(logn)  
#### delete
思想:用$H[n]$替代$H[i]$然后堆栈大小减1。如果有需要的话，根据$H[i]$的键值与存储在它父节点和子节点中元素键值的关系,对$H[i]$做shift-up和shift-down运算,直到满足堆特性。  
`伪代码:`  
输入: 删除$H[1..n]$和位于1和$n$之间的索引$i$。 
输出: 删除$H[i]$之后的新堆$H[1..n-1]$。 
1. $x \leftarrow H[i]$ 
2. $y \leftarrow H[n]$ 
3. $n \leftarrow n-1$ {decrease the size of H} 
4. if $i > n$ then exit {done} 
5. $H[i] \leftarrow y$ 
6. if $key(y) \geq key(x)$ then $\text{SHIFT-UP}(H,i)$ 
7. else $\text{SHIFT-DOWN}(H,i)$ 
8. end if
时间复杂度:O(logn)  
- 删除最大值:DELETE(H,1)即可  
### 创建堆  
思路一:从空堆开始，插入数组元素  
时间复杂度:O(nlogn)  
思路二:从非叶子节点($\lfloor n/2 \rfloor$)起，逐个调整  
时间复杂度:O(n)  
`伪代码:`
输入: $n$个元素的数组$A[1..n]$。 
输出: $A[1..n]$转换成堆  
1. for $i \leftarrow \lfloor n/2 \rfloor$ downto 1 
2. $\text{SHIFT-DOWN}(A, i)$ 
3. end for
### 堆排序
思想:将数组变成堆,将堆顶元素和堆底元素互换，并且堆规模减少1，然后重新调整为堆，重复直到只有一个元素  
输入: $n$个元素的数组$A[1..n]$。 
输出: 非降序排列的数组。 
1. $\text{MAKEHEAP}(A)$ 
2. for $j \leftarrow n$ downto 2 
3. 互换$A[1]$和$A[j]$ 
4. $\text{SHIFT-DOWN}(A[1..j-1], 1)$ 
5. end for
时间复杂度:建堆:O(n)  
		   排序:O(nlogn)  
		   综合:O(nlogn)  
空间复杂度:原地排序:O(1)  
### 最小堆和PRIM
#### 原始PRIM
思路:  
1. 把起始顶点归入 “已选集合”，剩余顶点归入 “未选集合”；
2. 每次选**已选集合与未选集合之间权值最小的边**，把对应未选顶点加入已选集合，并将这条边加入生成树；
3. 同时更新未选顶点到已选集合的最小边权（若通过新加入的顶点能得到更小边权）；
4. 重复至所有顶点都加入已选集合，即得到最小生成树。
##### 伪代码:
输入: 含权连通无向图$G=(V,E)$，其中$V=\{1,2,...,n\}$。 
输出: 由$G$生成的最小耗费生成树$T$组成的边的集合。 
1. $T \leftarrow \emptyset$；$X \leftarrow \{1\}$；$Y \leftarrow V - \{1\}$ 
2. for $y \leftarrow 2$ to $n$ 
3. if $y$ 邻接于$1$ then 
4. $N[y] \leftarrow 1$ 
5. $C[y] \leftarrow c[1,y]$ 
6. else $C[y] \leftarrow \infty$ 
7. end if 
8. end for 
9. for $j \leftarrow 1$ to $n-1$ {寻找$n-1$条边} 
10. 令$y \in Y$ 使得$C[y]$ 最小 
11. $T \leftarrow T \cup \{(y, N[y])\}$ {将边$(y, N[y])$加入$T$} 
12. $X \leftarrow X \cup \{y\}$ {将顶点$y$加入$X$} 
13. $Y \leftarrow Y - \{y\}$ {从$Y$删除顶点$y$} 
14. for 每个邻接于$y$的顶点$w \in Y$ 
15. if $c[y,w] < C[w]$ then 
16. $N[w] \leftarrow y$ 
17. $C[w] \leftarrow c[y,w]$ 
18. end if 
19. end for 
20. end for
时间复杂度:$\theta$(m+n^2),m为循环次数
#### 堆改进版
思路:用最小堆来保持边界顶点集
时间复杂度:$\theta$(m+logn)
##### 伪代码:
输入: 含权连通无向图$G=(V,E)$, where $V=\{1,2,...,n\}$. 
输出: 由$G$生成的最小耗费生成树$T$组成的边的集合。假设我们已有一个空堆$H$。 
1. $T \leftarrow \emptyset$；$Y \leftarrow V-\{1\}$ 
2. for $y \leftarrow 2$ to $n$ 
3. if $y$ 邻接于$1$ then 
4. $N[y] \leftarrow 1$ 
5. $\text{key}(y) \leftarrow c[1,y]$ 
6. $\text{INSERT}(H,y)$ 
7. else $\text{key}(y) \leftarrow \infty$ 
8. end if 
9. end for 
10. for $j \leftarrow 1$ to $n-1$ {查找$n-1$条边} 
11. $y \leftarrow \text{DELETEMIN}(H)$ 
12. $T \leftarrow T \cup \{(y, N[y])\}$ {添加边$(y, N[y])$到$T$} 
13. $Y \leftarrow Y - \{y\}$ {从$Y$删除顶点$y$} 
14. for 每个邻接于$y$的顶点$w \in Y$ 
15. if $c[y,w] < \text{key}(w)$ then 
16. $N[w] \leftarrow y$ 
17. $\text{key}(w) \leftarrow c[y,w]$ 
18. end if 
19. if $w \notin H$ then $\text{INSERT}(H,w)$ 
20. else $\text{SHIFTUP}(H, H^{-1}(w))$ 
21. end for 
22. end for
## 不相交集
### 描述
给出一个有n个不同元素的集合S,这些元素被分成不相交集合。在每个子集中，用一个特殊的元素作为集合的名字或代表。
树表示法:一个子集用树表示
eg:
![[不相交集表示树.png]]
### Union-find
#### Find(x)
作用:寻找并返回包含元素x的集合的名字
实现思路:从x开始直到根节点的路径,然后返回root(x)
伪代码:
Input: A node $x$. 
Output: The root of the tree containing $x$. 
1. $y \leftarrow x$ 
2. while $p(y) \neq \text{null}$ {Find the root of the tree containing $x$} 
3. $y \leftarrow p(y)$ 
4. end while 
5. return $y$ 
#### Union(x,y)
作用:包含元素x和y的两个集合用他们的并集替换。并集的名字或者是原来包含元素x的集合的名字,或者是包含y的
实现思路:让root(x)的链接指向root(y),也就是说，如果root(x)是u，root(y)是v，就令v是u的父节点
伪代码:
Input: Two elements $x$ and $y$. 
Output: The union of the two trees containing $x$ and $y$. The original trees are destroyed. 
1. $u \leftarrow \text{FIND}(x)$; $v \leftarrow \text{FIND}(y)$
2. $p(u) \leftarrow v$;
### 按秩合并和路径压缩
#### 原因
![[NOT USEFUL.png]]
#### 按秩合并(针对UNION)
- 原理:让较少节点的树的根指向包含较多节点的树的根，而这个树的大小可以抽象为树的高度，即高度小的树合并到高度大的树。
- 实现思想:每个节点存储一个非负数作为秩,记作rank，记录树的高度,在union的时候，比较rank(x),rank(y)
 - 如果rank(x)>rank(y),y为父节点
 - 如果rank(y)>rank(x),x为父节点
 - 如果相等,取y为父节点，rank(y)++
- 相关结论
 - p(x)为x的父节点
  - rank(p(x))>=rank(x)+1
  - rank(x)值为0，在后续合并运算序列中递增，直到X不为根节点，一旦x成为其他节点的子节点，其秩不再改变。
	- 由此而来的引理:包括根节点x在内的树中节点的个数至少是
  $$ 2^{rank(x)}$$
- 伪代码
Input: 两个元素$x$和$y$ 
Output: 包含$x$和$y$的两个树的合并，原来的树被破坏。 
1. $u \leftarrow \text{FIND}(x)$; $v \leftarrow \text{FIND}(y)$ 
2. if $\text{rank}(u) < \text{rank}(v)$ then 
3. $p(u) \leftarrow v$ 
4. if $\text{rank}(u) = \text{rank}(v)$ then $\text{rank}(v) \leftarrow \text{rank}(v)+1$ 
5. else $p(v) \leftarrow u$ 
6. end if
#### 路径压缩(针对FIND)
思路:在找到根节点y后，再一次遍历从x到y的路径，并沿着路径改变所有节点指向父节点的指针，使它们直接指向y
输入：node $x$ 
输出：$\text{root}(x)$, 包含$x$的树的根。 
1. $y \leftarrow x$ 
2. while $p(y) \neq \text{null}$ {寻找包含$x$的树的根} 
3. $y \leftarrow p(y)$ 
4. end while 
5. $\text{root} \leftarrow y$; $y \leftarrow x$ 
6. while $p(y) \neq \text{null}$ {执行路径压缩} 
7. $w \leftarrow p(y)$; $p(y) \leftarrow \text{root}$; $y \leftarrow w$ 
8. end while 
9. return $\text{root}$
### 时间复杂度:O(mlog*n)