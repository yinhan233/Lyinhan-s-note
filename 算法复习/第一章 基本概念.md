# 引入
#### 算法的定义
算法是定义好的能够完成一定任务的有限指令集合，通常由一个初始化状态，终止于一个对应的可识别的结束状态。
#### 算法的特征
有效性:算法必须能在有限的时间能够完成
确定性:算法的每一步能够清楚的定义
有限性:算法能够在有限的步骤完成
输入:有0个或多个
输出:至少1个
#### 算法的性能
空间/时间复杂度
其他的所需资源:通讯开销，处理器数目，等...
# 搜索问题
## 线性搜索
```伪代码
Input:An array A[1..n] of n elements and an element x.
Output:j if x=A[j], 1≤j≤n, and 0 otherwise.
1. j←1
2. while (j<n) and (x≠A[j])
3. j←j+1
4. end while
5. if x=A[j] then return j else return 0.
```
时间复杂度:O(n)
## 二分搜索
```
Input: 数组 A [1..n] 包含 n 个非递减次序的元，查找元素 x.
Output: j 若 x = A [j], 1 ≤ j ≤ n, and 0 otherwise.
1. low ← 1; high ← n; j ← 0
2. while (low ≤ high) and (j = 0)
3. mid ← ⌊(low+high)/2⌋
4. if x = A[mid] then j ← mid
5. else if x < A[mid] then high ← mid − 1
6. else low ← mid + 1
7. end while
8. return j
```
时间复杂度:O(logn)
# 排序问题
## 选择排序
思想:A[1]为最小元素，接着,从剩下的n-1个元素找最小的,存在A[2],重复以上过程，直到整个数组中第二大的元素存在A[n-1]
```伪代码
Input: 包含 n 个元素的数组 A [1..n].
Output: 使 A [1..n] 中的元素非递减排列
1. for i ← 1 to n-1
2. k ← i // 记录第 i 个最小元素的下标
3. for j ← i+1 to n
4. if A[j] < A[k] then k ← j
5. end for
6. if k ≠ i then 交换 A [i] 和 A [k]
7. end for
```
时间复杂度O(n^2)
## 插入排序
思想:从只包含一个元素的子数组A[1]开始,将A[2]插入到子数组A[1]的合适的位置,可能在A[1]前或后,之后A[1..2]变成有序的,重复该步骤
```伪代码
Input: An array A[1..n] of n elements.
Output: A[1..n] sorted in nondecreasing order.
1. for i ← 2 to n
2. x ← A[i]
3. 

4. while (j>0) and (A[j]>x)
5. A[j+1] ← A[j]
6. j ← j−1
7. end while
8. A[j+1] ← x
9. end for
```
时间复杂度:O(n^2)
## 合并两个有序的数组
思想:双指针法
```
Input: 数组 A [1..m] 和三个下标 p, q, r，其中 1≤p≤q<r≤m。该数组的两个子部分 A [p..q] 和 A [q+1..r] 是非递减排序
Output: A [p..r] 中的元素非递减排序
1. component ← q-p+1; k ← p
2. s ← p; t ← q+1 //s 是第一个子数组的指针，t 是第二个子数组的指针
3. while s ≤ q and t ≤ r
4. if A[s] ≤ A[t] then
5. B[k] ← A[s]; s ← s+1
6. else
7. B[k] ← A[t]; t ← t+1
8. end if
9. k ← k+1
10. end while
11. if s = q+1 then B[k..r] ← A[t..r]
12. else B[k..r] ← A[s..q]
13. A[p..r] ← B[p..r]
14. end for
```
时间复杂度:O(r−p+1)
## 自底向上合并
```
Input: 包含 n 个元素的数组 A [1..n]
Output: A [1..n] 按照非递减排序.
1. k ← 1 //k 是当前待合并的有序块的大小（初始每个元素为 1 个元素的有序块）
2. while k < n
3. s ← k; t ← 2*s; i ← 0 //t 是合并后块的大小，i 是当前合并的起始偏移
4. while i + t ≤ n // 遍历数组，合并相邻的两个大小为 s 的有序块
5. MERGE (A, i+1, i+s, i+t) // 合并 A [i+1..i+s] 和 A [i+s+1..i+t]
6. i ← i + t // 移动到下一组待合并的块
7. end while
8. if i + s <n then MERGE (A, i+1, i+s, n) // 合并剩余的不足 t 大小的块
9. k ← t // 块大小翻倍，进入下一轮合并
10. end while
```
时间复杂度:O(nlogn)
# 算法分析概念
## 时间/空间复杂度
### 时间复杂度
定义:对于输入规模n的算法元运算的次
元运算:对于任何计算步骤，它的代价有一个时间常量作为上界,而不管输入数据或执行的算法
Example:
加减乘除,元素比较和逻辑元算,元素赋值

| 符号      | 核心含义        | 对应算法场景     | 关键特征          |
| ------- | ----------- | ---------- | ------------- |
| O(g(n)) | 渐近上界        | 最坏时间复杂度    | 只约束「上限」，不约束下限 |
| Ω(g(n)) | 渐近下界        | 最好时间复杂度    | 只约束「下限」，不约束上限 |
| Θ(g(n)) | 渐近紧确界（精确量级） | 最好=最坏时间复杂度 | 同时约束「上限」和「下限」 |
### 空间复杂度
定义:为了求解问题的实例而执行的计算步骤所需要的内存空间，即算法所需要的工作空间
## 最优算法
定义：一般说来，如果我们能够证明解决问题$\pi$的时间复杂度为Ω(f(n)), 那么一个时间复杂度为O(f(n))的算法Q称为一个最优算法
## 如何评估算法运行时间
- 计算迭代的次数
- 计算基本操作的频度
 如果算法中的一个<font color="#2DC26B">元运算</font>具有<font color="#2DC26B">最高频率</font>，所以其他元运算频率均在他的频率的常数倍内，则这个元运算称为<font color="#2DC26B">基本运算</font>
√在搜索和排序算法中，元运算一般是元素比较
√在矩阵乘法运算中，数量乘法运算是元运算
√在遍历一个链表时，元运算是设置或更新指针
√在图遍历中，元运算是访问节点的 “动作” 和被访问节点的计数
- 使用递推关系
## 最坏和平均情况分析
