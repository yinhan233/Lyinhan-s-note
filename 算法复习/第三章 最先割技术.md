# 贪心算法
## 引言
贪心算法的思想:通过每次局部最优的选择实现整体最优或近似最优
### 引例
分数背包问题:通过计算物品$y_i$=$v_i/s_i$,然后比值降序,依次装背包，直到装满
### 架构
Algorithm GREEDY($A,n$)   
solution $\leftarrow \emptyset$   
for $i \leftarrow 1$ to $n$ do   
	$x \leftarrow \text{SELECT}(A)$  
if $\text{FEASIBLE}(\text{solution},x)$   
then solution $\leftarrow \text{UNION}(\text{solution},x)$   
end if   
end for     
return (solution)
### 什么时候用贪心
具有<font color="#f79646">贪心选择性质</font>和<font color="#f79646">最优子结构性质</font>  
##### 贪心选择性质:  
- 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。  
- 动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。  
- 对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。 

##### 最优子结构性质:
- 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。  
## 单源最短路径问题
### Dijkstra
思想:每一步选择距离源点最近的点,加入终点集,再更新。比之前短就更新。  
`伪代码:`  
输入：有权有向图 $G=(V,E)$，
其中 $V=\{1,2,\dots,n\}$。   
输出：$G$ 中顶点 1 到其他顶点的距离。 
1. $X \leftarrow \{1\}$；$Y \leftarrow V \setminus \{1\}$；$N[1] \leftarrow 0$ 
2. for $y \leftarrow 2$ to $n$ do 
3. if $y$ 相邻于 1 then $N[y] \leftarrow \text{length}[1,y]$ 
4. else $N[y] \leftarrow \infty$ 
5. end if 
6. end for 
7. for $i \leftarrow 1$ to $n-1$ do 
8. 令 $y \in Y$ 使得 $N[y]$ 最小 
9. $X \leftarrow X \cup \{y\}$（将顶点 $y$ 加入 $X$） 
10. $Y \leftarrow Y \setminus \{y\}$（将顶点 $y$ 从 $Y$ 中删除） 
11. for 每条边 $(y,w)$ 
12. if $w \in Y$ 且 $N[y] + \text{length}[y,w] < N[w]$ then 
13. $N[w] \leftarrow N[y] + \text{length}[y,w]$ 
14. end if 
15. end for
16. end for
时间复杂度:O($n^2$)
突破版本:O($mlog^(2/3)*n$)
### 稠图的线性时间算法
思想:  
- 用最小堆的数据结构来保持集合Y中的顶点，使得Y组中离V-Y最近的顶点y可以在O($log n$)的时间被选出  
- 每个顶点v相关的键就是它的标记$\lambda[v]$  
`伪代码`:
输入：含权有向图 $G=(V,E)$，其中 $V=\{1,2,\dots,n\}$。  
输出：$G$ 中顶点 1 到其他顶点的距离。假设已有一个空堆 $H$。   
1. $Y \leftarrow V \setminus \{1\}$；$\lambda[1] \leftarrow 0$；$\text{key}(1) \leftarrow \lambda[1]$ 
2. for $y \leftarrow 2$ to $n$ do 
3. if $y$ 邻接于 1 then 
4. $\lambda[y] \leftarrow \text{length}[1,y]$ 
5. $\text{key}(y) \leftarrow \lambda[y]$ 
6. $\text{INSERT}(H,y)$ 
7. else 
8. $\lambda[y] \leftarrow \infty$ 
9. $\text{key}(y) \leftarrow \lambda[y]$ 
10. end if 
11. end for 
12. for $j \leftarrow 1$ to $n-1$ do 
13. $y \leftarrow \text{DELETEMIN}(H)$ 
14. $Y \leftarrow Y \setminus \{y\}$ {将顶点 $y$ 从 $Y$ 中删除} 
15. for 每个邻接于 $y$ 的顶点 $w \in Y$ do 
16. if $\lambda[y] + \text{length}[y,w] < \lambda[w]$ then 
17. $\lambda[w] \leftarrow \lambda[y] + \text{length}[y,w]$ 
18. $\text{key}(w) \leftarrow \lambda[w]$ 
19. end if 
20. if $w \notin H$ then $\text{INSERT}(H,w)$ 
21. else $\text{IFTUP}(H,H(w))$ { $H(w)$ 返回 $w$ 在 $H$ 中的位置 } 
22. end if 
23. end for 
24. end for
时间复杂度:O(mlogn) 
突破版:$$O(m\log^{2/3} n)$$
## 最小耗费生成树
### Kruskal
思想:不断加入边,直到所有点被连接,并且无环  
`伪代码`:  
输入：包含$n$个顶点的含权连通无向图$G=(V,E)$。     
输出：$G$的最小耗费生成树$T$组成的边的集合。     
1. 按非降序权重将$E$中的边排序 
2. for 每条边$v \in V$ 
3. $\text{MAKESET}(v)$ 
4. end for 
5. $T = \emptyset$ 
6. while $|T| < n-1$ 
7. 令$(x,y)$为$E$中的下一条边 
8. if $\text{FIND}(x) \neq \text{FIND}(y)$ then {检查$x,y$是否在同一颗树中}
9. 将$(x,y)$加入$T$ 
10. $\text{UNION}(x,y)$ 
11. end if 
12. end while
### prim
思路:从一个点开始，不断地加入新的点，点到点之间路径最短    
伪代码:[[第一章 基本概念#最小堆和PRIM]]  
同样地，也可以通过最小堆来优化，详细请见上一个链接内容  
## 文件压缩
思路:通过满二叉树给文件的字母，按出现频度编码  
`伪代码`:  
输入：$n$个字符的集合 $C=\{c_1,c_2,\dots,c_n\}$ 和它们的频度 $\{f(c_1),f(c_2),\dots,f(c_n)\}$。   
输出：$C$ 的Huffman树 $T=(V,E)$。 
1. 根据频度将所有字符插入最小堆 $H$ 
2. $V \leftarrow C$；$T \leftarrow \emptyset$ 
3. for $i \leftarrow 1$ to $n-1$ do 
4. $c' \leftarrow \text{DELETEMIN}(H)$ 
5. $c'' \leftarrow \text{DELETEMIN}(H)$ 
6. $f(v) \leftarrow f(c') + f(c'')$ （$v$ 是一个新节点） 
7. $V \leftarrow V \cup \{v\}$ （添加 $v$ 到 $V$） 
8. $\text{INSERT}(H,v)$ 
9. $T \leftarrow T \cup \{(v,c'), (v,c'')\}$ （使 $c'$ 和 $c''$ 成为 $v$ 的孩子） 
10. end for
时间复杂度:O($nlogn$)