# 归纳
## 基本思想
将规模为n的问题递减成为规模为n−1或n/2的子问题，反复递减后对子问题分别求解，再建立子问题的解与原问题的解的关系。
归约法有两个主要的变形：
- 减常数 (如 1)：每次迭代规模减 1，即n→n−1
- 减因子 (如 1/2)：每次迭代规模减半，即n→n/2
给出的两个例子为:
### 选择排序-归纳法版
输入: $n$个元素的数组$A[1..n]$。 
输出: 按非降序排列的数组$A[1..n]$。 1. $\text{sort}(1)$ 
过程 $\text{sort}(i)$ {对$A[i..n]$排序} 
1. if $i < n$ then 
2. $k \leftarrow i$ 
3. for $j \leftarrow i+1$ to $n$ 
4. if $A[j] < A[k]$ then $k \leftarrow j$ {永远让$k$指向$i+1$到$n$中最小的那个数} 
5. end for 
6. if $k \neq i$ then 互换$A[j]$和$A[k]$ 
7. $\text{sort}(i+1)$ 
8. end if
时间复杂度:$\theta$($n^2$)
### 插入排序-归纳法版
输入: $n$个元素的数组$A[1..n]$。 
输出: 按非降序排列的数组$A[1..n]$。 1. $\text{sort}(n)$ 
过程 $\text{sort}(j)$ “对$A[1..j]$排序” 
1. if $j>1$ then 
2. $x \leftarrow A[j]$ “归约的将要插入的那个元素” 
3. $\text{sort}(j-1)$ “对$A[1..j-1]$排序” 
4. $i \leftarrow j-1$ 
5. while $i>0$ and $A[i]>x$ 
6. $A[i+1] \leftarrow A[i]$ 
7. $i \leftarrow i-1$ 
8. end while 
9. $A[i+1] \leftarrow x$ 
10. end if
时间复杂度:$\theta$($n^2$)
### Radix sort
思路:根据位数,对应数字位数上的数装入对应$L_0...L_9$的表中,然后取出，然后再依次转入桶中，直到达到最大次数。
输入: 一个有$n$个数的表$L=(a_1,...,a_n)$和$k$位数字。 
输出: 按顺序排列的$L$。 
1. for $j \leftarrow 1$ to $k$ 
2. 准备10个空表$L_0,L_1,...,L_9$ 
3. while $L$ 非空 
4. $a \leftarrow L$中的下一元素；删除$L$中的$a$ 
5. $i \leftarrow a$中的第$j$位数字；将$a$加入表$L_i$中 
6. end while 
7. $L \leftarrow L_0$ 
8. for $i \leftarrow 1$ to $9$ 
9. $L \leftarrow L,L_i$（将表$L_i$加入表$L$中） 
10. end for 
11. end for 
12. return $L$
时间复杂度:O(n)
空间复杂度:O(n)
### Horner's规则
基本思想 首先观察多项式： $$P_n(x) = a_nx^n + a_{n-1}x^{n-1} + \dots + a_1x + a_0$$ 将其变形为嵌套求值形式： $$P_n(x) = ((((a_nx + a_{n-1})x + a_{n-2})x + a_{n-3})\dots x + a_1)x + a_0$$ 这种求值的安排称为Horner规则
导出: $$P_{n-1}(x) = a_n x^{n-1} + a_{n-1}x^{n-2} + \dots + a_2 x + a_1$$ 得到以下更有效的方法： $$p_n(x) = x p_{n-1}(x) + a_0,\ p_j(x) = x p_{j-1}(x) + a_{n-j}$$  
`伪代码:`  
input:n+2个实数$a_0...a_n$和x的序列 
Output: $p$（多项式$P_n(x)$的值） 
1. $p \leftarrow a_n$ 
2. for $i \leftarrow 1$ to $n$ 
3. $p \leftarrow x \cdot p + a_{n-i}$ 
4. end for 
5. return $p$
### topo sort
思路:减治法，每次选择没有前驱的点，删除以这个点为起点的边，重复该步骤，直到最后一个节点被输出
### 生成排列 
思路:假定生成n-1个数字的全排列
先生成2,3,...n的排列，然后每个排列前面加上1，然后生成1,3,4...n的排列，然后每个排列前面加上2，重复该过程  
`伪代码:`  
Input: 正整数$n$. 
Output: 数$1,2,...,n$的所有可能排列 
1. for $j \leftarrow 1$ to $n$ // 生成数组 
2. $P[j] \leftarrow j$ 
3. end for 
4. $\text{perm1}(1)$

过程 $\text{perm1}(m)$ 
1. if $m = n$ then output $P[1..n]$ 
2. else 
3. for $j \leftarrow m$ to $n$ 
4. 互换$P[j]$和$P[m]$ 
5. $\text{perm1}(m+1)$ 
6. 互换$P[j]$和$P[m]$ 
7. comment: at this point $$P[m..n]=m,\ m+1,\ ...,\ n$$ 
8. end for 
9. end if
时间复杂度:O(nn!)
### EXP
思路:令$m=\lfloor n/2 \rfloor$，假设已经知道如何计算$x^m$，那么有两种情况： - 如果$n$是偶数，那么 $$x^n = (x^m)^2$$
 - 否则， $$x^n = x(x^m)^2$$
#### EXPREC
输入: 实数$x$和非负整数$n$ 
输出: $x^n$ 
过程: $\text{power}(x, m)$ 
1. if $m=0$ then $y \leftarrow 1$ 
2. else 
3. $y \leftarrow \text{power}(x, \lfloor m/2 \rfloor)$ 
4. $y \leftarrow y^2$ 
5. if $m$为奇数 then $y \leftarrow x \cdot y$ 
6. endif 
7. return $y$
时间复杂度:O(logn)
#### EXP(根据二进制做,没讲) 
输入: 实数$x$和非负整数$n$ 
输出: $x^n$ 
1. $y \leftarrow 1$ 
2. 将$n$用二进制数$d_k d_{k-1} ... d_0$表示（$d_k$为二进制最高位，$d_0$为最低位） 
3. for $j \leftarrow k$ downto $0$ 
4. $y \leftarrow y^2$ 
5. if ($d_j=1$) then $y \leftarrow x \cdot y$ 
6. end for 
7. return $y$
时间复杂度:O(logn)
### 假币问题
思路:分三堆
# 分治
思路:把一个问题分成若干实例，然后递归解决，然后组合解。  
通常步骤:划分->治理->组合
## 简例
### MINMAX
思路:
1. 将数组分割成两半：$A[1..\lfloor n/2 \rfloor]$ 和 $A[\lfloor n/2 \rfloor + 1..n]$； 
2. 在每一半中找到最大值和最小值； 
3. 并返回这两个最小值中的最小值，以及这两个最大值中的最大值。
   
`伪代码`:  
输入: $n$个整数元素的数组$A[1..n]$，$n$为2的幂。 输出: $(x,y)$: $A$中的最大元素和最小元素。 
过程 $\text{minmax}(\text{low},\text{high})$ 
1. if $\text{high}-\text{low}=1$ then {数组只有2个值的情况} 
2. if $A[\text{low}] \leq A[\text{high}]$ then return $(A[\text{low}], A[\text{high}])$ 
3. else return $(A[\text{high}], A[\text{low}])$ 
4. end if 
5. else 
6. $\text{mid} \leftarrow \lfloor (\text{low}+\text{high})/2 \rfloor$ 
7. $(x_1,y_1) \leftarrow \text{minmax}(\text{low}, \text{mid})$ 
8. $(x_2,y_2) \leftarrow \text{minmax}(\text{mid}+1, \text{high})$ 
9. $x \leftarrow \min(x_1,x_2)$ 
10. $y \leftarrow \max(y_1,y_2)$ 
11. return $(x,y)$ 
12. end if
### 二分搜索
将一个给定的元素$x$与一个已排序数组$A[\text{low}..\text{high}]$的中间元素做比较 
- 如果$x < A[\text{mid}]$，这里$\text{mid}=\lfloor (\text{low} + \text{high})/2 \rfloor$，则不考虑$A[\text{mid}..\text{high}]$，而对$A[\text{low}..\text{mid}-1]$重复实施相同的方法。 
- 类似地，如果$x > A[\text{mid}]$，则放弃$A[\text{low}..\text{mid}]$，而对$A[\text{mid}+1..\text{high}]$重复实施相同的方法。
`伪代码`:  
输入: 按非降序排列的$n$个元素的数组$A[1..n]$和元素$x$。 
输出: 如果$x=A[j]$，$1 \le j \le n$，则输出$j$；否则输出$0$ 
1. $\text{binarysearch}(1,n)$ 
   
过程 $\text{binarysearch}(\text{low},\text{high})$ 	   
1. if $\text{low} > \text{high}$ then return $0$ 
2. else 
3. $\text{mid} \leftarrow \lfloor (\text{low}+\text{high})/2 \rfloor$ 
4. if $x=A[\text{mid}]$ then return $\text{mid}$ 
5. else if $x < A[\text{mid}]$ then return $\text{binarysearch}(\text{low},\text{mid}-1)$ 
6. else return $\text{binarysearch}(\text{mid}+1,\text{high})$ 
7. end if
### 合并排序(自底向上)
思路:将一个数组分成两半，然后自底向上合并
输入: $n$个元素的数组$A[1..n]$。 
输出: 按非降序排列的数组$A[1..n]$。 
1. $\text{mergesort}(A,1,n)$ 
   
过程 $\text{mergesort}(A,\text{low},\text{high})$ 
1. if $\text{low} < \text{high}$ then 
2. $\text{mid} \leftarrow \lfloor (\text{low}+\text{high})/2 \rfloor$ 
3. $\text{mergesort}(A,\text{low},\text{mid})$ 
4. $\text{mergesort}(A,\text{mid}+1,\text{high})$ 
5. $\text{MERGE}(A,\text{low},\text{mid},\text{high})$ 
6. end if
时间复杂度:$\theta$(nlogn)
空间复杂度:$\theta$(n)
## 基于分治策略解决问题
### 快速排序
时间复杂度:$\theta$(nlogn)
空间复杂度:$\theta$(logn)和$\theta$(n)之间
优点:原位排序
缺点:不稳定
思路:
- 设A[low..high]是含n个数的数组，取x=A[low]（作为 “基准元素”）；
- 重新排列数组元素，使**小于等于x的元素位于x之前，大于x的元素位于x之后**；
- 调整后，x会处于数组的某个位置w（满足low≤w≤high），即x=A[w]。
##### 划分算法
算法6.5 SPLIT 
输入: 数组$A[\text{low}..\text{high}]$。 
输出: 
(1) 如必要，输出按上述描述重新排列的数组$A$； 
(2) 划分元素$A[\text{low}]$的新位置$w$。 
1. $i \leftarrow \text{low}$ 
2. $x \leftarrow A[\text{low}]$ 
3. for $j \leftarrow \text{low}+1$ to $\text{high}$ 
4. if $A[j] \le x$ then 
5. $i \leftarrow i+1$ 
6. if $i \neq j$ then 互换$A[i]$和$A[j]$ 
7. end if 
8. end for 
9. 互换$A[\text{low}]$和$A[i]$ 
10. $w \leftarrow i$ 
11. return $A$和$w$
##### 快速排序
通过spilt排序A[w],然后对子序列再进行排序
输入: $n$个元素的数组$A[1..n]$ 
输出: 按非降序排列的数组$A$中的元素 
1. $\text{quicksort}(A,1,n)$
    
过程 $\text{quicksort}(A,\text{low},\text{high})$ 
1. if $\text{low} < \text{high}$ then 
2. $w=\text{SPLIT}(A[\text{low}..\text{high}])$ { $w$为$A[\text{low}]$的新位置 } 
3. $\text{quicksort}(A,\text{low},w-1)$ 
4. $\text{quicksort}(A,w+1,\text{high})$ 
5. end if
### 第k小元素
输入: $n$个元素的数组$A[1..n]$和整数$k$，$1 \le k \le n$。 
输出: $A$中的第$k$小元素。 
1. $\text{select}(A,1,n,k)$ 
   
过程 $\text{select}(A,\text{low},\text{high},k)$ 
1. $p \leftarrow \text{high}-\text{low}+1$ 
2. if $p < 44$ then 将$A$排序 并 return $A[k]$ 
3. Let $q = \lceil p/5 \rceil$: 将$A$分成$q$组，每组5个元素。如果$p$不整除5，则剩余元素为一组。 
4. 将$q$组中的每一组单独排序，找出中项。所有中项的集合为$M$ 
5. $mm \leftarrow \text{select}(M,1,q,\lceil q/2 \rceil)$ { $mm$为中项集合$M$的中项 } 
6. 将$A[\text{low}..\text{high}]$分成三组： $A1=\{a \mid a \le mm\}$，$A2=\{a \mid a=mm\}$，$A3=\{a \mid a>mm\}$ 
7. case: 
- $k \le |A1|$: 
  return $\text{select}(A1,1,|A1|,k)$ 
- $|A1|+1 \le k \le |A1|+|A2|$: 
  return $mm$ 
- $|A1|+|A2| < k$: 
  return $\text{select}(A3,1,|A3|,k-|A1|-|A2|)$ 
8. end case
### 大整数乘法
#### 传统分治
思路:将n位的二进制整数u和v各分2段，每段长为n/2位
假定n是2的幂 . $u = w2^{n/2} + x$ $v = y2^{n/2} + z$ 
u和v的乘积可以计算为： $uv = (w2^{n/2} + x)(y2^{n/2} + z) = wy2^n + (xy + wz)2^{n/2} + xz$   
时间复杂度函数为： $$T(n)= \begin{cases} d & \text{if } n=1 \\ 4T(n/2)+bn & \text{if } n>1 \end{cases}$$ 递推式的解： $T(n) = \Theta(n^2)$
#### Karatsuba 优化
现在考虑： $wz + xy = (w + x)(y + z) - wy - xz$ 
我们得到： $uv = wy2^n + ((w + x)(y + z) - wy - xz)2^{n/2} + xz$ 
时间复杂度是： $$T(n)= \begin{cases} d & \text{if } n=1 \\ 3T(n/2)+bn & \text{if } n>1 \end{cases}$$ 递推式的解是： $T(n) = \Theta(n^{\log_2 3}) = O(n^{1.59})$
### 矩阵乘法
#### 分治
假定$n=2^k$，$k \ge 0$，如果$n \ge 2$，则矩阵$A$、$B$、$C$可分别分成4个大小为$n/2×n/2$的子矩阵： $$A=\begin{pmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \end{pmatrix},\ B=\begin{pmatrix} B_{11} & B_{12} \\ B_{21} & B_{22} \end{pmatrix},\ C=\begin{pmatrix} C_{11} & C_{12} \\ C_{21} & C_{22} \end{pmatrix}$$ 用分治方法计算$C$的组成（传统矩阵分治乘法）： $$C=\begin{pmatrix} A_{11}B_{11}+A_{12}B_{21} & A_{11}B_{12}+A_{12}B_{22} \\ A_{21}B_{11}+A_{22}B_{21} & A_{21}B_{12}+A_{22}B_{22} \end{pmatrix}$$
最终时间复杂度：Θ(n3)
STRASSEN算法 
基本思想：先计算7个中间乘积： 
$d_1=(a_{11}+a_{22})(b_{11}+b_{22})$ $d_2=(a_{21}+a_{22})b_{11}$ $d_3=a_{11}(b_{12}-b_{22})$ $d_4=a_{22}(b_{21}-b_{11})$ $d_5=(a_{11}+a_{12})b_{22}$ $d_6=(a_{21}-a_{11})(b_{11}+b_{12})$ $d_7=(a_{12}-a_{22})(b_{21}+b_{22})$   
再通过中间乘积推导$C$： $$C=\begin{pmatrix} d_1+d_4-d_5+d_7 & d_3+d_5 \\ d_2+d_4 & d_1+d_3-d_2+d_6 \end{pmatrix}$$
最终时间复杂度：Θ(nlog2​7)≈O(n2.81)
### 最近点问题
思路:
- Sort: 第一步是以x坐标增序对$S$中的点排序 
- Divide: $S$点集被垂直直线$L$大约划分成两个子集$S_1$和$S_2$，使$|S_1|=\lceil |S|/2 \rceil$，$|S_2|=\lfloor |S|/2 \rfloor$，设$L$是经过$x$坐标$\lceil |S|/2 \rceil$的点的直线，这样在$S_1$中的所有点落在或靠近$L$的左边，而所有$S_2$中的点落在或靠近$L$的右边。 
- Conquer: 现在按上述递归地进行，两个子集$S_1$和$S_2$的最小间距$\delta_1$和$\delta_2$可分别计算出来。 
- Combine: 组合步骤是把在$S_1$中的点与$S_2$中的点之间的最小间距$\delta'$计算出来。最后所要求的解是$\delta_1$、$\delta_2$和$\delta'$中的最小值。  
`伪代码:`  
输入: 平面上$n$个点的集合$S$。 
输出: $S$中两点的最小距离。 
1. 以$x$坐标增序对$S$中的点排序，得到$X$。 
2. 以$y$坐标增序对$S$中的点排序，得到$Y$。 
3. $\delta \leftarrow \text{cp}(1,n)$ 

过程 $\text{cp}(\text{low},\text{high})$ 
1. if $\text{high}-\text{low}+1 \le 3$ then 用直接方法计算$\delta$ 
2. else 
3. $\text{mid} \leftarrow \lfloor (\text{low}+\text{high})/2 \rfloor$ 
4. $x_0 \leftarrow X[\text{mid}]$的$x$坐标 
5. $\delta_1 \leftarrow \text{cp}(\text{low},\text{mid})$ 
6. $\delta_2 \leftarrow \text{cp}(\text{mid}+1,\text{high})$ 
7. $\delta \leftarrow \min(\delta_1, \delta_2)$ 
8. end if 
9. $k \leftarrow 0$ 
10. for $i \leftarrow 1$ to $n$ {从$Y$中抽取$T$} 
11. if $|Y[i]$的$x$坐标 $- x_0| \le \delta$ then 
12. $k \leftarrow k+1$ 
13. $T[k] \leftarrow Y[i]$ 
14. end if 
15. end for 
16. $\delta' \leftarrow 2\delta$ 
17. for $i \leftarrow 1$ to $k-1$ 
18. for $j \leftarrow i+1$ to $\min(i+7,k)$ 
19. if $d(T[i],T[j]) < \delta'$ then $\delta' \leftarrow d(T[i],T[j])$ 
20. end for 
21. end for 
22. $\delta \leftarrow \min(\delta,\delta')$ 
23. return $\delta$
# 动态规划
