# 回溯法
## 相关概念和思想
1. 解空间  
设问题的解向量为$X=(x_1,x_2,\dots,x_n)$，$x_i$的取值范围为有穷集$S_i$。把$x_i$的所有可能取值组合，称为问题的解空间。每一个组合是问题的一个可能解。  
2. 状态空间树  
问题解空间的树形式表示  
- 树中的每个结点确定所求解问题的一个**问题状态**。   
- 由根结点到其它结点的所有路径确定了这个问题的**状态空间**。   
- **解状态**是这样一些问题状态$S$：对于这些问题状态，由根到$S$的那条路径确定了解空间中的一个元组。   
- **答案状态**是这样的一些解状态$S$：对于这些解状态而言，由根到$S$的这条路径确定了问题的一个解。  
- **活结点**：如果已生成一个结点而它的儿子结点还没有全部生成，则这个结点叫活结点；当前正在生成其儿子结点的活结点叫**E-结点（正在扩展的结点）**。   
- **死结点**：不再进一步扩展或者其儿子结点已经全部生成的生成结点是死结点。  
3. 回溯法（backtracking）  
是一种系统地搜索问题解的方法。为实现回溯，首先需要定义一个解空间（solution space），然后以易于搜索的方式组织解空间，最后用**深度优先**的方法搜索解空间，获得问题的解。  
## 问题要求   
- 所要求的解必须能表示成一个$n$-元组$(x_1,x_2,\dots,x_n)$，其中$x_i$是取自某个有穷集$S_i$。通常，所求解的问题需要求取一个使某一个规范函数  $P(x_1,x_2,\dots,x_n)$取极值或满足规范条件的向量，有时还要找出满足$P$的所有向量。   
- 许多问题还要求所有的解满足一组综合的约束条件，这些条件分两种类型：**显式约束**和**隐式约束**。   
	- **显式约束**：限定每个$x_i$只从一个给定的集合上取值，满足显式约束的所有元组确定一个可能的**解空间**。   
	- **隐式约束**：规定解空间中那些实际上满足规范函数的元组，因此描述了$x_i$必须彼此相关的情况。  
## 问题的求解方法:
假定集合$S_i$的大小为$m_i$，于是就有$m = m_1 m_2 \dots m_n$个$n$-元组可能满足函数$P$。   
1. **硬性处理求解方法** 构造出$m$个$n$-元组并逐一测试它们是否满足$P$，从而找出该问题的所有最优解。   
2. **回溯处理求解方法** 不断地用修改过的规范函数$P_1(x_1,x_2,\dots,x_n)$（有时称为限界函数）去测试正在构造中的$n$-元组的部分向量$(x_1,x_2,\dots,x_i)$，看其是否可能导致（最优）解。如果判定$(x_1,x_2,\dots,x_i)$不可能导致（最优）解，那么就将可能要测试的$m_{i+1}m_{i+2}\dots m_n$个向量一概略去。
### 回溯法的求解步骤
1. 定义一个解空间，它包含问题的解   
2. 用易于搜索的方式组织解空间  
3. 深度优先搜索解空间，获得问题的解  

**剪枝函数**:  
- **约束函数**:在扩展顶点处剪去不满足约束的子树
- **限界函数**:剪去不能得到最优解的子树。
## 3着色问题
思路:通过完全三叉树作为搜索树，每一条路径代表一种颜色指派，不符合要求时候变成死节点
### 递归解法
**输入**: 无向图 $G=(V,E)$。   
**输出**: $G$ 的顶点的3着色 $c[1..n]$，其中每个 $c[i]$ 为1,2或3.
1. for k ← 1 to n 
2. c[k] ← 0 
3. end for 
4. flag ← false 
5. graphcolor(1)
6. if flag then output c 
7. else output "no solution"

子过程:graphycolor(k)  

1. for color ← 1 to 3 
2. c[k] ← color 
3. if c 为合法着色 then flag ← true and exit 
4. else if c 是部分的 then graphcolor(k+1) 
5. end for
### 迭代解法
**输入**: 无向图 $G=(V,E)$。  
**输出**:G的顶点的三着色c[1..n],其中每个c[j]为1,2或3
1. for k ← 1 to n 
2. c[k] ← 0 
3. end for 
4. flag ← false 
5. k ← 1 
6. while k ≥ 1 
7. while c[k] ≤ 2 
8. c[k] ← c[k] + 1 
9. if c 为全着色 then 设置 flag ← true 且从两个while循环退出 
10. else if c 是部分解 then k ← k+1 (前进) 
11. end while 12. c[k] ← 0 
12. k ← k-1 (回溯) 
13. end while 
14. if flag then output c 
15. else output "no solution"
### 复杂度:
时间:O($n3^n$)  
空间:O(n)  
## 4皇后问题
描述:
如何在$8\times8$的国际象棋棋盘上安排8个皇后，使得没有两个皇后能互相攻击？如果两个皇后处在同一行、同一列或同一条对角线上，则她们能互相攻击。  
`伪代码`:  
**输入**：空。  
**输出**：对应于4皇后问题的解的向量 $x[1..4]$。  
1. for k ← 1 to 4 
2. x[k] ← 0 {没有皇后放置在棋盘上} 
3. end for 
4. flag ← false 
5. k ← 1 
6. while k ≥ 1 
7. while x[k] < 3 
8. x[k] ← x[k] + 1 
9. if x 为合法解 then set flag ← true 且从两个while循环退出 
10. else if x 是部分解 then k ← k+1 {前进} 
11. end while 
12. x[k] ← 0 
13. k ← k-1 {回溯} 
14. end while 
15. if flag then output x 
16. else output "no solution"
## 一般回溯方法
### 递归版:
算法13.4 BACKTRACKREC     
输入:集合$X_1,X_2,\dots,X_n$的清楚的或隐含的描述。   
输出:解向量$v=(x_1,x_2,\dots,x_n)$,$0 \le i \le n$.   
1. $v \leftarrow ()$ 
2. $flag \leftarrow false$ 
3. $advance(1)$ 
4. if $flag$ then output $v$ 
5. else output "no solution" 

过程 $advance(k)$   
1. for each $x \in X_k$ 
2. $x_k \leftarrow x$; 将$x_k$加入$v$ 
3. if $v$为最终解then set $flag \leftarrow true$ and exit 
4. else if $v$是部分解then $advance(k+1)$ 
5. end for
### 迭代版
算法13.5 BACKTRACKITER   
输入:集合$X_1,X_2,\dots,X_n$的清楚的或隐含的描述。   
输出:解向量$v=(x_1,x_2,\dots,x_n)$,$0 \le i \le n$.   
1. $v \leftarrow ()$ 
2. $flag \leftarrow false$ 
3. $k \leftarrow 1$ 
4. while $k \ge 1$ 
5. while $X_k$没有被穷举 
6. $x_k \leftarrow X_k$中的下一个元素; 将$x_k$加入$v$ 
7. if $v$为最终解then set $flag \leftarrow true$且两个while循环退出 
8. else if $v$是部分解then $k \leftarrow k+1$ {前进} 
9. end while 
10. 重置$X_k$，使得下一个元素排在第一位 
11. $k \leftarrow k-1$ 
12. end while 
13. if $flag$ then output $v$ 
14. else output "no solution"
## 子集和数问题
描述:已知$n+1$个正数：$w_i(1\le i\le n)$，和$M$，要求找出$w_i$的和数是$M$ 的所有子集   
解的表示形式: 采用定长元组:解为$n$元组$(X_1,X_2,\dots,X_n)$，其中$X_i$表取0或1， 表示$w_i$的在子集合中是否出现。   
约束条件: 并设定$w_i(1\le i\le n)$按非降次序排列。$$\sum_{i=1}^n w(i)x(i)=M$$    
限界函数:  
$B_k(x(1),\dots,x(k))=\text{true}$ 当且仅当: $$\sum_{i=1}^k w(i)x(i)+w(k+1)>M$$   
假定$w_i$已经按照非降次序排列,则可以强化限界函数,如果下式 成立,$B_k(x(1),\dots,x(k))$为假: $$\sum_{i=1}^k w(i)x(i)+\sum_{i=k+1}^n w(i)\ge M$$   
故,假定$w_i$已经按照非降次序排列,限界函数$B_k(x(1),\dots,x(k))=\text{true}$ 当且仅当:   
$$\sum_{i=1}^k w(i)x(i)+\sum_{i=k+1}^n w(i)\ge M \text{ 并且 } \sum_{i=1}^k w(i)x(i)+w(k+1)\le M$$  
`伪代码`:  
算法SUMOFSUBREC   
输入:$w[1..n]$,$n$和$M$,$w[i]>0$,$M>0$.   
输出:A solution vector$x[1..n]$,where each$x[i]$is 0 or 1
1. for$k\leftarrow 1$to$n$ 
2. $x[k]\leftarrow 0$ 
3. end for 
4. flag$\leftarrow$false 
5. $s\leftarrow 0$;$r\leftarrow w[1]+w[2]+\dots+w[n]$ 
6. if $r<M$ then SUMOFSUB(s,$k$,$r$)endif 
7. else if flag then output$x$ 
8. else output "no solution" 
9. end if Procedure 
     
SUMOFSUB(s,k,r)   
1. $x[k]\leftarrow 1$ 
2. if$s+w[k]=M$ 
3. then set flag$\leftarrow$true and exit 
4. else 
5. if$s+w[k]+w[k+1]\le M$//$x$是部分的$B_k=\text{true}$, 第$k$个数放入 
6. then SUMOFSUB(s+w[k],k+1,r-w[k])//递归调用第$k+1$个数 
7. end if 
8. end if 
9. if$s+(r-w[k])\ge M$//$B_k=\text{false}$第$k$个数不放入 
10. then$x[k]\leftarrow 0$, SUMOFSUB(s,k+1,r-w[k]) 
11. end if
## 哈密顿回路问题
已知图$G=(V,E)$是一个$n$个结点的连通图。连通图$G$的一个哈密顿 环(Hamiltonian cycle)是图$G$的一个回路，它经过图中每个结点，且 只经过一次。一个哈密顿环是从某个结点$v_0$开始，沿着图$G$的$n$ 条边环行的一条路径$(v_0,v_1,\dots,v_{n-1},v_n)$，其中$(v_i,v_{i+1})\in E,0\le i<n$， 它访问图中每个结点且只访问一次，最后返回开始结点，即除 $v_0=v_n$，路径上其余结点各不相同。  
解题思路:  
对于$n$个结点的图$G=(V,E)$的哈密顿环问题，可采用$n$ 元组表示问题的解$(x_0,x_1,\dots,x_{n-1})$。每个$x_i\in\{0,1,\dots,n-1\}$，$0\le i<n$，代表路径上一个结点的编号，这就是显式 约束。因此解空间的大小为$n!$。  
其隐式约束可描述为： $x_i\neq x_j,0\le i,j<n,i\neq j$，且$(x_i,x_{i+1})\in E$，$x_i,x_{i+1}\in V$， $i=0,1,\dots,n-2$，又$(x_{n-1},x_0)\in E$。   
哈密顿环问题的分析和求解方法与图的$m$-着色问题 非常相似
## 0-1背包问题
在0/1背包问题中，需对容量为$c$的背包进行装载。   
从$n$个物品中选取装入背包的物品，每件物品 $i$的重量为$w_i$,价值为$p_i$。对于可行的背包装载，背包 中的物品的总重量不能超过背包的容量，最佳装载 是指所装入的物品价值最高，即$\sum_{i=1}^n p_i x_i$取得最大值。   
<font color="#f79646">约束条件</font>为$$\sum_{i=1}^n w_i x_i \le c$$和$$x_i\in\{0,1\}(1\le i\le n)$$    
在这个表达式中，需求出$x_i$的值。$x_i=1$表示物 品$i$装入背包中，$x_i=0$表示物品$i$不装入背包。
# 分治限界法
![[Compare.png]]  
- **分支-限界法**: 在生成当前E-结点的全部儿子之后再生成其它结点 的儿子，并且，用限界函数帮助避免生成不包含答案结点子树。  
- **检索策略分为**: 
1. **FIFO(first in first out)检索**: 类似于BFS的状态空间检索，它的 活动结点表采用一张先进先出表(队列) 
2. **LC-检索 (最小耗费检索)**
	- **解决**: 对活结点使用一个"有智力的"排序函数$c(\cdot)$来选取下一个E-结点， 使有可能产生答案结点的结点优先称为E-结点，从而可以 加快到达一个答案结点的检索速度 
	- **此时若适当地基于最小代价（LC）的搜索策略则可以通过 $c(n)=d(n)+w(n)$来近似估计取得最优解的可能性，从而尽可能的减少 空间中状态。**
## 15谜问题
### 问题描述:
- 在一个分成$4\times4$的棋盘上排列15块号牌，其中会出现一个空格。 棋盘上牌的一次合法移动是指将位于空格上、下、左、右的 一块号牌移入空格。要求通过一系列合法移动，将号牌的初始 排列转换成自然排列。
### 解题思路(普通解法)
1. 棋盘上方格编号 如果将棋盘上的各个位置按照号牌的自然排列发个序号， 右下角为16号。
2. 记$\text{POSITION}(i)$为编号$i$的牌在初始状态中的位置； $\text{POSITION}(16)$表示空格的位置。
3. $\text{LESS}(i)$是这样牌的数目： $j<i$，但$\text{POSITION}(j)>\text{POSITION}(i)$， 即编号小于$i$但初始位置在$i$之后的牌的数目。
4. 引入一个量$X$ 如图所示，初始状态时， 若空格落在红色方格上，则$X=1$； 若空格落在白色方格上，则$X=0$；![[15谜.png]]
5. 初始状态能否经过若干步合法移动到达目标状态， 可由定理1给出：  
	- 定理1 当且仅当$\sum_{i=1}^{15} \text{LESS}(i)+X$ 是偶数时，目标状态才 能由初始状态经过若干步后到达；
### 基于LC搜索策略
- 成本函数$c(l)$：从根出发到最近目标结点路径上的每个 结点赋予这条路径的长度作为它们的成本。 
- 估计成本函数$\hat{c}(X): \hat{c}(X)=h(X)+\hat{g}(X)$， 
- $h(X)$是由根到结点$X$的路径的长度； 
- $\hat{g}(X)$是对以$X$为根的子树中由$X$到目标状态的一条路径长 度的估计。它至少应是能把状态$X$转换成目标状态所需的 最小移动数。 
- $\hat{g}(X)=$不在其目标位置的非空白牌数目 
- 可以看出$\hat{c}(X)$是$c(X)$的下界。
![[图例.png]]
`伪代码:`  
Input: 状态空间树$T$,$T$中结点的估计成本函数$\hat{c}$。   
Output: 问题的解（从根到答案结点的路径）   
1. if T 是答案节点 then 输出T and return; end if 
2. $E \leftarrow T$ //E-结点 
3. 将活结点表初始为空 
4. repeat 
5. for E 的每个儿子 X 
6. if X 是答案结点 then 
7. 输出从X到T的路径, return 
8. end if 
9. call ADD(X) //将新的活结点X加到活结点表中 
10. PARENT(X) ← E //E结点标记为X的父结点 
11. end for 
12. if 活结点表为空 then 
13. 输出 "无解", return 
14. end if 
15. call LEAST(E) //找一个具有最小$\hat{c}$值的活结点放到E中，从活结点表中删除 
16. end repeat
## TSP Problem
### 写在前面
建议看视频
[如果只要知道怎么做看这个，但是这个和教材的规约矩阵结合没有结合！](https://www.bilibili.com/video/av115875583759507/)  
[印度老哥的，这个视频和教材那个规约矩阵结合的很好,牛逼!](https://www.bilibili.com/video/av114427240258897/)
### 问题描述
给出一个城市的集合和一个定义在每一对城市间的耗费函数， 找出耗费最小的旅行。在这里，一个旅行是一个闭合的路径， 它访问每个城市恰好一次，也就是说，是一个简单回路。耗费 函数可以是距离、旅行时间、飞机票价等。
### 视频归纳(第一个视频)
#### 第一步:寻找上下界
先贪心找到问题的上界(每个局部最优最短路径)  
然后以此为约束,寻找下界  
下界为:每个点出发，选择最小的两个点，加和，最后除2  
RT:  
![[下界.png]]
为什么要最小的两个->每个顶点度数为2，这样才能构成回路  
#### 第二步:确定限界函数
$lb = \left( 2\sum_{i=1}^{k-1} c[r_i][r_{i+1}] + \sum_{r_i \in U} r_i行不在路径上的最小元素 + \sum_{r_j \in U} r_j行最小的两个元素 \right) / 2$
其中，U为当前路径,k为确定的顶点，注意，$r_i$要满足度为1,例如1->2->3,$r_i$={1,3}  
`伪代码`:  
输入：图$G=(V,E)$ 输出：最短哈密顿回路 
1. 根据限界函数计算目标函数的下界$\text{down}$；采用贪心法得到上界$\text{up}$； 
2. 计算根结点的目标函数值并加入待处理结点表$\text{PT}$； 
3. 循环直到某个叶子结点的目标函数值在表$\text{PT}$中取得极小值   
	 3.1 $i \leftarrow \text{PT}$中具有最小值的结点；   
	 3.2 对结点$i$的每个孩子结点$x$执行下列操作：   
		 3.2.1 估算结点$x$的目标函数值$\text{lb}$；  
		 3.2.2 若$\text{lb}<\text{up}$，则将结点$x$加入表$\text{PT}$中；否则丢弃该结点； 
4. 将叶子结点对应的最优值输出，回溯求得最优解的各个分量。  
### 一般解题思路
通过状态搜索树搜索即可
### 归约代价矩阵
• 归约代价矩阵 
• 对**第i行** 是将该行的每个元素减去该行的约数得到新行。 
• 对矩阵的一行进行归约，可以将该行中的每个元素减去 该行的最小数进行，此最小数称为该行的约数。
• 同理，**列约**等价于对以顶点为头的所有边的权值都 减去该列的规约数，得到一个与原图结构相同的有向图， 但每条周游路径长度将因此减少。 
• 对矩阵的一列进行归约，可以将该**列**中的每个元素减去 该列的最小数进行，此最小数称为该列的约数。
### 基于归约代价矩阵的LC+FIFO讲解
1. 对于初始矩阵，规约化(每行每列减去最小的并且记录在列/行尾部),加和得到c
2. 从1开始bfs
	1. 以1->2 为例，将第一行和第二列的所有数字设为无穷
	2. 将2,1设为无穷,代表不可返回
	3. 规约化矩阵(检查每行每列是否含0或者全为无穷),计算出新的$c_i$
	4. 当前路径cost=c+c(1,2)+$c_i$,(c(1,2)从原来的矩阵看)
3. 在此基础上，如果对1->2,3,4...的继续遍历，称为FIFO，如果针对最小的结点，则为LC(Least-cost)
