# P类
定义:设$A$是求解问题$\Pi$的一个算法，如果在展示问题$\Pi$的一个实例时，在整个执行过程中，每一步都只有一种选择，则称$A$是确定性算法。因此如果对于同样的输入，实例一遍又一遍地执行，它的输出从不改变。 
定理:P类问题在补运算下封闭  
# NP类
定义:NP类由这样的问题$\Pi$组成，对于这些问题存在一个确定性算法$A$，该算法在对$\Pi$的一个实例展示一个断言解时，它能在多项式时间内验证解的正确性。即如果断言解导致答案是yes，就存在一种方法可以在多项式时间内验证这个解。  
# 不确定性算法
两个阶段:
- 猜测阶段
- 验证阶段
- 定义(不确定性算法)：设$A$是求解问题$\Pi$的一个算法，如果算法$A$以“猜测+验证”的方式工作，称算法$A$为不确定性(nondeterminism)算法。  
- 猜测阶段：对问题的输入实例产生一个任意字串$y$，在算法的每次运行中，$y$可能不同，因此猜测是以不确定的形式工作。这个工作一般可以在线性时间内完成。  
- 验证阶段：在这个阶段，用一个确定性算法验证两件事：首先验证猜测的$y$是否是合适的形式，若不是，则算法停下并回答“no”；若是合适形式，则继续检查它是否是问题的解。如果确实是$x$的解，则停下并回答“yes”，否则停下并回答“no”。要求验证阶段在多项式时间内完成。  
# NPC类问题
**NPC类问题**（Nondeterminism Polynomial complete）：存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件：
首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。  
要证明npc问题的思路就是： 先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它。
# NPH类(了解即可)
NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是它不一定是一个NP问题。
# 常见问题归纳
<font color="#f79646">P</font>:排序问题类,单源最短路径问题（无负权）,最小生成树问题类,字符串匹配问题类,线性规划问题类  
<font color="#f79646">NP</font>(解验证复杂度+目前最佳求解复杂度):旅行商问题（TSP）,子集和问题,图 k- 着色问题  
<font color="#f79646">NPC</font>:布尔可满足性问题（SAT）,3-SAT 问题,顶点覆盖问题,团问题,哈密顿回路问题,子集和问题（判定版)  
# P,NP,NPC,NPH图解关系
![[P,NP,NPC.png]]
![[P,NP,NPC,NPH.png]]